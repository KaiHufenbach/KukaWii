<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Wed Dec 13 16:20:21 PST 2006 -->
<TITLE>
Canvas3D (Java 3D 1.5.0)
</TITLE>

<META NAME="keywords" CONTENT="javax.media.j3d.Canvas3D class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Canvas3D (Java 3D 1.5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/media/j3d/BranchGroup.html" title="class in javax.media.j3d"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/media/j3d/CapabilityNotSetException.html" title="class in javax.media.j3d"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/media/j3d/Canvas3D.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Canvas3D.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_java.awt.Canvas">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.media.j3d</FONT>
<BR>
Class Canvas3D</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.awt.Component
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by ">java.awt.Canvas
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>javax.media.j3d.Canvas3D</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.awt.image.ImageObserver, java.awt.MenuContainer, java.io.Serializable, javax.accessibility.Accessible</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Canvas3D</B><DT>extends java.awt.Canvas</DL>
</PRE>

<P>
The Canvas3D class provides a drawing canvas for 3D rendering.  It
 is used either for on-screen rendering or off-screen rendering.
 Canvas3D is an extension of the AWT Canvas class that users may
 further subclass to implement additional functionality.
 <p>
 The Canvas3D object extends the Canvas object to include 
 3D-related information such as the size of the canvas in pixels, 
 the Canvas3D's location, also in pixels, within a Screen3D object, 
 and whether or not the canvas has stereo enabled.
 <p>
 Because all Canvas3D objects contain a 
 reference to a Screen3D object and because Screen3D objects define 
 the size of a pixel in physical units, Java 3D can convert a Canvas3D 
 size in pixels to a physical world size in meters. It can also 
 determine the Canvas3D's position and orientation in the
 physical world.
 <p>
 <b>On-screen Rendering vs. Off-screen Rendering</b>
 <p>
 The Canvas3D class is used either for on-screen rendering or 
 off-screen rendering.
 On-screen Canvas3Ds are added to AWT or Swing Container objects
 like any other canvas.  Java 3D automatically and continuously
 renders to all on-screen canvases that are attached to an active
 View object.  On-screen Canvas3Ds can be either single or double
 buffered and they can be either stereo or monoscopic.
 <p>
 Off-screen Canvas3Ds must not be added to any Container.  Java 3D
 renders to off-screen canvases in response to the
 <code>renderOffScreenBuffer</code> method.  Off-screen Canvas3Ds
 are single buffered.  However, on many systems, the actual
 rendering is done to an off-screen hardware buffer or to a 3D
 library-specific buffer and only copied to the off-screen buffer of
 the Canvas when the rendering is complete, at "buffer swap" time.
 Off-screen Canvas3Ds are monoscopic.
 <p>
 The setOffScreenBuffer method sets the off-screen buffer for this 
 Canvas3D. The specified image is written into by the Java 3D renderer. 
 The size of the specified ImageComponent determines the size, in 
 pixels, of this Canvas3D - the size inherited from Component is 
 ignored. Note that the size, physical width, and physical height of the
 associated Screen3D must be set
 explicitly prior to rendering. Failure to do so will result in an 
 exception.
 <p>
 The getOffScreenBuffer method retrieves the off-screen 
 buffer for this Canvas3D.
 <p>
 The renderOffScreenBuffer method schedules the rendering of a frame 
 into this Canvas3D's off-screen buffer. The rendering is done from 
 the point of view of the View object to which this Canvas3D has been 
 added. No rendering is performed if this Canvas3D object has not been 
 added to an active View. This method does not wait for the rendering 
 to actually happen. An application that wishes to know when the 
 rendering is complete must either subclass Canvas3D and
 override the postSwap method, or call waitForOffScreenRendering.
 <p>
 The setOfScreenLocation methods set the location of this off-screen 
 Canvas3D.  The location is the upper-left corner of the Canvas3D 
 relative to the upper-left corner of the corresponding off-screen 
 Screen3D. The function of these methods is similar to that of 
 Component.setLocation for on-screen Canvas3D objects. The default 
 location is (0,0).
 <p>
 <b>Accessing and Modifying an Eye's Image Plate Position</b>
 <p>
 A Canvas3D object provides sophisticated applications with access 
 to the eye's position information in head-tracked, room-mounted 
 runtime environments. It also allows applications to manipulate 
 the position of an eye relative to an image plate in non-head-tracked 
 runtime environments.
 <p>
 The setLeftManualEyeInImagePlate and setRightManualEyeInImagePlate
 methods set the position of the manual left and right eyes in image 
 plate coordinates. These values determine eye placement when a head 
 tracker is not in use and the application is directly controlling the 
 eye position in image plate coordinates. In head-tracked mode or 
 when the windowEyepointPolicy is RELATIVE_TO_FIELD_OF_VIEW or
 RELATIVE_TO_COEXISTENCE, this 
 value is ignored. When the windowEyepointPolicy is RELATIVE_TO_WINDOW, 
 only the Z value is used.
 <p>
 The getLeftEyeInImagePlate, getRightEyeInImagePlate, and
 getCenterEyeInImagePlate methods retrieve the actual position of the 
 left eye, right eye, and center eye in image plate coordinates and 
 copy that value into the object provided. The center eye is the 
 fictional eye half-way between the left and right eye. These three 
 values are a function of the windowEyepointPolicy, the tracking 
 enable flag, and the manual left, right, and center eye positions.
 <p>
 <b>Monoscopic View Policy</b>
 <p>
 The setMonoscopicViewPolicy and getMonoscopicViewPolicy methods
 set and retrieve the policy regarding how Java 3D generates monoscopic 
 view. If the policy is set to View.LEFT_EYE_VIEW, the view generated 
 corresponds to the view as seen from the left eye. If set to 
 View.RIGHT_EYE_VIEW, the view generated corresponds to the view as 
 seen from the right eye. If set to View.CYCLOPEAN_EYE_VIEW, the view 
 generated corresponds to the view as seen from the "center eye," the 
 fictional eye half-way between the left and right eye. The default 
 monoscopic view policy is View.CYCLOPEAN_EYE_VIEW.
 <p>
 <b>Immediate Mode Rendering</b>
 <p>
 Pure immediate-mode rendering provides for those applications and 
 applets that do not want Java 3D to do any automatic rendering of 
 the scene graph. Such applications may not even wish to build a 
 scene graph to represent their graphical data. However, they use 
 Java 3D's attribute objects to set graphics state and Java 3D's 
 geometric objects to render geometry.
 <p>
 A pure immediate mode application must create a minimal set of 
 Java 3D objects before rendering. In addition to a Canvas3D object, 
 the application must create a View object, with its associated 
 PhysicalBody and PhysicalEnvironment objects, and the following 
 scene graph elements: a VirtualUniverse object, a high-resolution 
 Locale object, a BranchGroup node object, a TransformGroup node 
 object with associated transform, and a ViewPlatform 
 leaf node object that defines the position and orientation within
 the virtual universe that generates the view.
 <p>
 In immediate mode, all rendering is done completely under user 
 control. It is necessary for the user to clear the 3D canvas, 
 render all geometry, and swap the buffers.  Additionally, 
 rendering the right and left eye for stereo viewing becomes the
 sole responsibility of the application.  In pure immediate mode, 
 the user must stop the Java 3D renderer, via the
 Canvas3D object <code>stopRenderer</code> method, prior to adding the 
 Canvas3D object to an active View object (that is, one that is 
 attached to a live ViewPlatform object).
 <p>
 Other Canvas3D methods related to immediate mode rendering are:
 <p>
 <ul>
 <code>getGraphicsContext3D</code> retrieves the immediate-mode 
 3D graphics context associated with this Canvas3D. It creates a 
 new graphics context if one does not already exist.
 <p>
 <code>getGraphics2D</code> retrieves the 
 2D graphics object associated with this Canvas3D. It creates a 
 new 2D graphics object if one does not already exist.
 <p>
 <code>swap</code> synchronizes and swaps buffers on a 
 double-buffered canvas for this Canvas3D object. This method 
 should only be called if the Java 3D renderer has been stopped. 
 In the normal case, the renderer automatically swaps
 the buffer.
 </ul>

 <p>
 <b>Mixed Mode Rendering</b>
 <p>
 Mixing immediate mode and retained or compiled-retained mode 
 requires more structure than pure immediate mode. In mixed mode, 
 the Java 3D renderer is running continuously, rendering the scene 
 graph into the canvas.

 <p>
 Canvas3D methods related to mixed mode rendering are:

 <p>
 <ul>
 <code>preRender</code> called by the Java 3D rendering loop after 
 clearing the canvas and before any rendering has been done for 
 this frame. 
 <p>
 <code>postRender</code> called by the Java 3D rendering loop after
 completing all rendering to the canvas for this frame and before 
 the buffer swap.
 <p>
 <code>postSwap</code> called by the Java 3D rendering loop after 
 completing all rendering to the canvas, and all other canvases 
 associated with this view, for this frame following the
 buffer swap.
 <p>
 <code>renderField</code> called by the Java 3D rendering loop 
 during the execution of the rendering loop. It is called once 
 for each field (i.e., once per frame on a mono system or once 
 each for the right eye and left eye on a two-pass stereo system. 
 </ul>
 <p>
 The above callback methods are called by the Java 3D rendering system
 and should <i>not</i> be called by an application directly.

 <p>
 The basic Java 3D <i>stereo</i> rendering loop, 
 executed for each Canvas3D, is as follows:
 <ul><pre>
 clear canvas (both eyes)
 call preRender()                           // user-supplied method
 set left eye view
 render opaque scene graph objects
 call renderField(FIELD_LEFT)               // user-supplied method
 render transparent scene graph objects
 set right eye view
 render opaque scene graph objects again
 call renderField(FIELD_RIGHT)              // user-supplied method
 render transparent scene graph objects again
 call postRender()                          // user-supplied method
 synchronize and swap buffers
 call postSwap()                            // user-supplied method
 </pre></ul>
 <p>
 The basic Java 3D <i>monoscopic</i> rendering loop is as follows:
 <ul><pre>
 clear canvas
 call preRender()                            // user-supplied method
 set view
 render opaque scene graph objects
 call renderField(FIELD_ALL)                 // user-supplied method
 render transparent scene graph objects
 call postRender()                           // user-supplied method
 synchronize and swap buffers
 call postSwap()                             // user-supplied method
 </pre></ul>
 <p>
 In both cases, the entire loop, beginning with clearing the canvas 
 and ending with swapping the buffers, defines a frame. The application 
 is given the opportunity to render immediate-mode geometry at any of 
 the clearly identified spots in the rendering loop. A user specifies 
 his or her own rendering methods by extending the Canvas3D class and 
 overriding the preRender, postRender, postSwap, and/or renderField 
 methods.
 Updates to live Geometry, Texture, and ImageComponent objects
 in the scene graph are not allowed from any of these callback
 methods.

 <p>
 <b>Serialization</b>
 <p>
 Canvas3D does <i>not</i> support serialization.  An attempt to
 serialize a Canvas3D object will result in an
 UnsupportedOperationException being thrown.

 <p>
 <b>Additional Information</b>
 <p>
 For more information, see the
 <a href="doc-files/intro.html">Introduction to the Java 3D API</a> and
 <a href="doc-files/ViewModel.html">View Model</a>
 documents.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Screen3D.html" title="class in javax.media.j3d"><CODE>Screen3D</CODE></A>, 
<A HREF="../../../javax/media/j3d/View.html" title="class in javax.media.j3d"><CODE>View</CODE></A>, 
<A HREF="../../../javax/media/j3d/GraphicsContext3D.html" title="class in javax.media.j3d"><CODE>GraphicsContext3D</CODE></A>, 
<A HREF="../../../serialized-form.html#javax.media.j3d.Canvas3D">Serialized Form</A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_java.awt.Canvas"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class java.awt.Canvas</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>java.awt.Canvas.AccessibleAWTCanvas</CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_java.awt.Component"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Nested classes/interfaces inherited from class java.awt.Component</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>java.awt.Component.AccessibleAWTComponent, java.awt.Component.BltBufferStrategy, java.awt.Component.FlipBufferStrategy</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#FIELD_ALL">FIELD_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies a single-field rendering loop.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#FIELD_LEFT">FIELD_LEFT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the left field of a field-sequential stereo rendering loop.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#FIELD_RIGHT">FIELD_RIGHT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the right field of a field-sequential stereo rendering loop.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.Component"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class java.awt.Component</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>BOTTOM_ALIGNMENT, CENTER_ALIGNMENT, LEFT_ALIGNMENT, RIGHT_ALIGNMENT, TOP_ALIGNMENT</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.image.ImageObserver"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface java.awt.image.ImageObserver</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>ABORT, ALLBITS, ERROR, FRAMEBITS, HEIGHT, PROPERTIES, SOMEBITS, WIDTH</CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#Canvas3D(java.awt.GraphicsConfiguration)">Canvas3D</A></B>(java.awt.GraphicsConfiguration&nbsp;graphicsConfiguration)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs and initializes a new Canvas3D object that Java 3D
 can render into.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#Canvas3D(java.awt.GraphicsConfiguration, boolean)">Canvas3D</A></B>(java.awt.GraphicsConfiguration&nbsp;graphicsConfiguration,
         boolean&nbsp;offScreen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs and initializes a new Canvas3D object that Java 3D
 can render into.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#addNotify()">addNotify</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Canvas3D uses the addNotify callback to track when it is added
 to a container.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Rectangle</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getBounds()">getBounds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Rectangle</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getBounds(java.awt.Rectangle)">getBounds</A></B>(java.awt.Rectangle&nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getCenterEyeInImagePlate(javax.vecmath.Point3d)">getCenterEyeInImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the actual position of the center eye
 in image-plate
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getDoubleBufferAvailable()">getDoubleBufferAvailable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a status flag indicating whether or not double
 buffering is available.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getDoubleBufferEnable()">getDoubleBufferEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a status flag indicating whether or not double
 buffering is enabled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/J3DGraphics2D.html" title="class in javax.media.j3d">J3DGraphics2D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getGraphics2D()">getGraphics2D</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the 2D graphics object associated with
 this Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/GraphicsContext3D.html" title="class in javax.media.j3d">GraphicsContext3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getGraphicsContext3D()">getGraphicsContext3D</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the immediate mode 3D graphics context associated with
 this Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getHeight()">getHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getImagePlateToVworld(javax.media.j3d.Transform3D)">getImagePlateToVworld</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current ImagePlate coordinates to Virtual World
 coordinates transform and places it into the specified object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getInverseVworldProjection(javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getInverseVworldProjection</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;leftInverseProjection,
                           <A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;rightInverseProjection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the inverse of the current Vworld projection transform
 for each eye into the specified Transform3D objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getLeftEyeInImagePlate(javax.vecmath.Point3d)">getLeftEyeInImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the actual position of the left eye
 in image-plate
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getLeftManualEyeInImagePlate(javax.vecmath.Point3d)">getLeftManualEyeInImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the position of the user-specified, manual left eye
 in image-plate
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Point</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getLocation()">getLocation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Point</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getLocation(java.awt.Point)">getLocation</A></B>(java.awt.Point&nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Point</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getLocationOnScreen()">getLocationOnScreen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getMonoscopicViewPolicy()">getMonoscopicViewPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns policy on how Java 3D generates monoscopic view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/ImageComponent2D.html" title="class in javax.media.j3d">ImageComponent2D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getOffScreenBuffer()">getOffScreenBuffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the off-screen buffer for this Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Point</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getOffScreenLocation()">getOffScreenLocation</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the location of this off-screen Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Point</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getOffScreenLocation(java.awt.Point)">getOffScreenLocation</A></B>(java.awt.Point&nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the location of this off-screen Canvas3D and stores
 it in the specified Point object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getPhysicalHeight()">getPhysicalHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the physical height of this canvas window in meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getPhysicalWidth()">getPhysicalWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the physical width of this canvas window in meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getPixelLocationFromImagePlate(javax.vecmath.Point3d, javax.vecmath.Point2d)">getPixelLocationFromImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;imagePlatePoint,
                               <A HREF="../../../javax/vecmath/Point2d.html" title="class in javax.vecmath">Point2d</A>&nbsp;pixelLocation)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Projects the specified point from image plate coordinates
 into AWT pixel coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getPixelLocationInImagePlate(int, int, javax.vecmath.Point3d)">getPixelLocationInImagePlate</A></B>(int&nbsp;x,
                             int&nbsp;y,
                             <A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;imagePlatePoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the position of the specified AWT pixel value
 in image-plate
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getPixelLocationInImagePlate(javax.vecmath.Point2d, javax.vecmath.Point3d)">getPixelLocationInImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point2d.html" title="class in javax.vecmath">Point2d</A>&nbsp;pixelLocation,
                             <A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;imagePlatePoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the position of the specified AWT pixel value
 in image-plate
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getRightEyeInImagePlate(javax.vecmath.Point3d)">getRightEyeInImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the actual position of the right eye
 in image-plate
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getRightManualEyeInImagePlate(javax.vecmath.Point3d)">getRightManualEyeInImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the position of the user-specified, manual right eye
 in image-plate
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getSceneAntialiasingAvailable()">getSceneAntialiasingAvailable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a status flag indicating whether or not scene
 antialiasing is available.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/Screen3D.html" title="class in javax.media.j3d">Screen3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getScreen3D()">getScreen3D</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieve the Screen3D object that this Canvas3D is attached to.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Dimension</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getSize()">getSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.awt.Dimension</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getSize(java.awt.Dimension)">getSize</A></B>(java.awt.Dimension&nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getStereoAvailable()">getStereoAvailable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a status flag indicating whether or not stereo
 is available.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getStereoEnable()">getStereoEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a status flag indicating whether or not stereo
 is enabled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/View.html" title="class in javax.media.j3d">View</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getView()">getView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets view that points to this Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getVworldProjection(javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)">getVworldProjection</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;leftProjection,
                    <A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;rightProjection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the current Vworld projection transform for each eye
 into the specified Transform3D objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getVworldToImagePlate(javax.media.j3d.Transform3D)">getVworldToImagePlate</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current Virtual World coordinates to ImagePlate
 coordinates transform and places it into the specified object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getWidth()">getWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getX()">getX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#getY()">getY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#isOffScreen()">isOffScreen</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a flag indicating whether this Canvas3D is an
 off-screen canvas.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#isRendererRunning()">isRendererRunning</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the state of the renderer for this Canvas3D object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#isShadingLanguageSupported(int)">isShadingLanguageSupported</A></B>(int&nbsp;shadingLanguage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a flag indicating whether or not the specified shading
 language is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#paint(java.awt.Graphics)">paint</A></B>(java.awt.Graphics&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Canvas3D uses the paint callback to track when it is possible to
 render into the canvas.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#postRender()">postRender</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This routine is called by the Java 3D rendering loop after completing
 all rendering to the canvas for this frame and before the buffer swap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#postSwap()">postSwap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This routine is called by the Java 3D rendering loop after completing
 all rendering to the canvas, and all other canvases associated with
 this view, for this frame following the buffer swap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#preRender()">preRender</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This routine is called by the Java 3D rendering loop after clearing
 the canvas and before any rendering has been done for this frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#queryProperties()">queryProperties</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a read-only Map object containing key-value pairs that define
 various properties for this Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#removeNotify()">removeNotify</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Canvas3D uses the removeNotify callback to track when it is removed
 from a container.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#renderField(int)">renderField</A></B>(int&nbsp;fieldDesc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This routine is called by the Java 3D rendering loop during the
 execution of the rendering loop.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#renderOffScreenBuffer()">renderOffScreenBuffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Schedules the rendering of a frame into this Canvas3D's
 off-screen buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#setDoubleBufferEnable(boolean)">setDoubleBufferEnable</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns double buffering on or off.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#setLeftManualEyeInImagePlate(javax.vecmath.Point3d)">setLeftManualEyeInImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the position of the manual left eye in image-plate
 coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#setMonoscopicViewPolicy(int)">setMonoscopicViewPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies how Java 3D generates monoscopic view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#setOffScreenBuffer(javax.media.j3d.ImageComponent2D)">setOffScreenBuffer</A></B>(<A HREF="../../../javax/media/j3d/ImageComponent2D.html" title="class in javax.media.j3d">ImageComponent2D</A>&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the off-screen buffer for this Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#setOffScreenLocation(int, int)">setOffScreenLocation</A></B>(int&nbsp;x,
                     int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the location of this off-screen Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#setOffScreenLocation(java.awt.Point)">setOffScreenLocation</A></B>(java.awt.Point&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the location of this off-screen Canvas3D.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#setRightManualEyeInImagePlate(javax.vecmath.Point3d)">setRightManualEyeInImagePlate</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the position of the manual right eye in image-plate
 coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#setStereoEnable(boolean)">setStereoEnable</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns stereo on or off.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#startRenderer()">startRenderer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Start the Java 3D renderer on this Canvas3D object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#stopRenderer()">stopRenderer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stop the Java 3D renderer on this Canvas3D object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#swap()">swap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Synchronize and swap buffers on a double buffered canvas for
 this Canvas3D object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/Canvas3D.html#waitForOffScreenRendering()">waitForOffScreenRendering</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Waits for this Canvas3D's off-screen rendering to be done.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Canvas"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.awt.Canvas</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>createBufferStrategy, createBufferStrategy, getAccessibleContext, getBufferStrategy, update</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Component"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.awt.Component</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>action, add, addComponentListener, addFocusListener, addHierarchyBoundsListener, addHierarchyListener, addInputMethodListener, addKeyListener, addMouseListener, addMouseMotionListener, addMouseWheelListener, addPropertyChangeListener, addPropertyChangeListener, applyComponentOrientation, areFocusTraversalKeysSet, bounds, checkImage, checkImage, coalesceEvents, contains, contains, createImage, createImage, createVolatileImage, createVolatileImage, deliverEvent, disable, disableEvents, dispatchEvent, doLayout, enable, enable, enableEvents, enableInputMethods, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, firePropertyChange, getAlignmentX, getAlignmentY, getBackground, getColorModel, getComponentAt, getComponentAt, getComponentListeners, getComponentOrientation, getCursor, getDropTarget, getFocusCycleRootAncestor, getFocusListeners, getFocusTraversalKeys, getFocusTraversalKeysEnabled, getFont, getFontMetrics, getForeground, getGraphics, getGraphicsConfiguration, getHierarchyBoundsListeners, getHierarchyListeners, getIgnoreRepaint, getInputContext, getInputMethodListeners, getInputMethodRequests, getKeyListeners, getListeners, getLocale, getMaximumSize, getMinimumSize, getMouseListeners, getMouseMotionListeners, getMousePosition, getMouseWheelListeners, getName, getParent, getPeer, getPreferredSize, getPropertyChangeListeners, getPropertyChangeListeners, getToolkit, getTreeLock, gotFocus, handleEvent, hasFocus, hide, imageUpdate, inside, invalidate, isBackgroundSet, isCursorSet, isDisplayable, isDoubleBuffered, isEnabled, isFocusable, isFocusCycleRoot, isFocusOwner, isFocusTraversable, isFontSet, isForegroundSet, isLightweight, isMaximumSizeSet, isMinimumSizeSet, isOpaque, isPreferredSizeSet, isShowing, isValid, isVisible, keyDown, keyUp, layout, list, list, list, list, list, locate, location, lostFocus, minimumSize, mouseDown, mouseDrag, mouseEnter, mouseExit, mouseMove, mouseUp, move, nextFocus, paintAll, paramString, postEvent, preferredSize, prepareImage, prepareImage, print, printAll, processComponentEvent, processEvent, processFocusEvent, processHierarchyBoundsEvent, processHierarchyEvent, processInputMethodEvent, processKeyEvent, processMouseEvent, processMouseMotionEvent, processMouseWheelEvent, remove, removeComponentListener, removeFocusListener, removeHierarchyBoundsListener, removeHierarchyListener, removeInputMethodListener, removeKeyListener, removeMouseListener, removeMouseMotionListener, removeMouseWheelListener, removePropertyChangeListener, removePropertyChangeListener, repaint, repaint, repaint, repaint, requestFocus, requestFocus, requestFocusInWindow, requestFocusInWindow, reshape, resize, resize, setBackground, setBounds, setBounds, setComponentOrientation, setCursor, setDropTarget, setEnabled, setFocusable, setFocusTraversalKeys, setFocusTraversalKeysEnabled, setFont, setForeground, setIgnoreRepaint, setLocale, setLocation, setLocation, setMaximumSize, setMinimumSize, setName, setPreferredSize, setSize, setSize, setVisible, show, show, size, toString, transferFocus, transferFocusBackward, transferFocusUpCycle, validate</CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FIELD_LEFT"><!-- --></A><H3>
FIELD_LEFT</H3>
<PRE>
public static final int <B>FIELD_LEFT</B></PRE>
<DL>
<DD>Specifies the left field of a field-sequential stereo rendering loop.
 A left field always precedes a right field.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.media.j3d.Canvas3D.FIELD_LEFT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FIELD_RIGHT"><!-- --></A><H3>
FIELD_RIGHT</H3>
<PRE>
public static final int <B>FIELD_RIGHT</B></PRE>
<DL>
<DD>Specifies the right field of a field-sequential stereo rendering loop.
 A right field always follows a left field.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.media.j3d.Canvas3D.FIELD_RIGHT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FIELD_ALL"><!-- --></A><H3>
FIELD_ALL</H3>
<PRE>
public static final int <B>FIELD_ALL</B></PRE>
<DL>
<DD>Specifies a single-field rendering loop.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.media.j3d.Canvas3D.FIELD_ALL">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Canvas3D(java.awt.GraphicsConfiguration)"><!-- --></A><H3>
Canvas3D</H3>
<PRE>
public <B>Canvas3D</B>(java.awt.GraphicsConfiguration&nbsp;graphicsConfiguration)</PRE>
<DL>
<DD>Constructs and initializes a new Canvas3D object that Java 3D
 can render into. The following Canvas3D attributes are initialized
 to default values as shown:
 <ul>
 left manual eye in image plate : (0.142, 0.135, 0.4572)<br>
 right manual eye in image plate : (0.208, 0.135, 0.4572)<br>
 stereo enable : true<br>
 double buffer enable : true<br>
 monoscopic view policy : View.CYCLOPEAN_EYE_VIEW<br>
 off-screen mode : false<br>
 off-screen buffer : null<br>
 off-screen location : (0,0)<br>
 </ul>
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>graphicsConfiguration</CODE> - a valid GraphicsConfiguration object that
 will be used to create the canvas.  This object should not be null and
 should be created using a GraphicsConfigTemplate3D or the
 getPreferredConfiguration() method of the SimpleUniverse utility.  For
 backward compatibility with earlier versions of Java 3D, a null or
 default GraphicsConfiguration will still work when used to create a
 Canvas3D on the default screen, but an error message will be printed.
 A NullPointerException or IllegalArgumentException will be thrown in a
 subsequent release.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the specified
 GraphicsConfiguration does not support 3D rendering</DL>
</DL>
<HR>

<A NAME="Canvas3D(java.awt.GraphicsConfiguration, boolean)"><!-- --></A><H3>
Canvas3D</H3>
<PRE>
public <B>Canvas3D</B>(java.awt.GraphicsConfiguration&nbsp;graphicsConfiguration,
                boolean&nbsp;offScreen)</PRE>
<DL>
<DD>Constructs and initializes a new Canvas3D object that Java 3D
 can render into.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>graphicsConfiguration</CODE> - a valid GraphicsConfiguration object
 that will be used to create the canvas.  This must be created either
 with a GraphicsConfigTemplate3D or by using the
 getPreferredConfiguration() method of the SimpleUniverse utility.<DD><CODE>offScreen</CODE> - a flag that indicates whether this canvas is
 an off-screen 3D rendering canvas.  Note that if offScreen
 is set to true, this Canvas3D object cannot be used for normal
 rendering; it should not be added to any Container object.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the GraphicsConfiguration
 is null.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the specified
 GraphicsConfiguration does not support 3D rendering<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="paint(java.awt.Graphics)"><!-- --></A><H3>
paint</H3>
<PRE>
public void <B>paint</B>(java.awt.Graphics&nbsp;g)</PRE>
<DL>
<DD>Canvas3D uses the paint callback to track when it is possible to
 render into the canvas.  Subclasses of Canvas3D that override this
 method need to call super.paint() in their paint method for Java 3D
 to function properly.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>paint</CODE> in class <CODE>java.awt.Canvas</CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>g</CODE> - the graphics context</DL>
</DD>
</DL>
<HR>

<A NAME="addNotify()"><!-- --></A><H3>
addNotify</H3>
<PRE>
public void <B>addNotify</B>()</PRE>
<DL>
<DD>Canvas3D uses the addNotify callback to track when it is added
 to a container.  Subclasses of Canvas3D that override this
 method need to call super.addNotify() in their addNotify() method for Java 3D
 to function properly.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>addNotify</CODE> in class <CODE>java.awt.Canvas</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeNotify()"><!-- --></A><H3>
removeNotify</H3>
<PRE>
public void <B>removeNotify</B>()</PRE>
<DL>
<DD>Canvas3D uses the removeNotify callback to track when it is removed
 from a container.  Subclasses of Canvas3D that override this
 method need to call super.removeNotify() in their removeNotify()
 method for Java 3D to function properly.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>removeNotify</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getScreen3D()"><!-- --></A><H3>
getScreen3D</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/Screen3D.html" title="class in javax.media.j3d">Screen3D</A> <B>getScreen3D</B>()</PRE>
<DL>
<DD>Retrieve the Screen3D object that this Canvas3D is attached to.
 If this Canvas3D is an off-screen buffer, a new Screen3D object
 is created corresponding to the off-screen buffer.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the 3D screen object that this Canvas3D is attached to</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphicsContext3D()"><!-- --></A><H3>
getGraphicsContext3D</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/GraphicsContext3D.html" title="class in javax.media.j3d">GraphicsContext3D</A> <B>getGraphicsContext3D</B>()</PRE>
<DL>
<DD>Get the immediate mode 3D graphics context associated with
 this Canvas3D.  A new graphics context object is created if one does
 not already exist.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a GraphicsContext3D object that can be used for immediate
 mode rendering to this Canvas3D.</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphics2D()"><!-- --></A><H3>
getGraphics2D</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/J3DGraphics2D.html" title="class in javax.media.j3d">J3DGraphics2D</A> <B>getGraphics2D</B>()</PRE>
<DL>
<DD>Get the 2D graphics object associated with
 this Canvas3D.  A new 2D graphics object is created if one does
 not already exist.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a Graphics2D object that can be used for Java 2D
 rendering into this Canvas3D.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="preRender()"><!-- --></A><H3>
preRender</H3>
<PRE>
public void <B>preRender</B>()</PRE>
<DL>
<DD>This routine is called by the Java 3D rendering loop after clearing
 the canvas and before any rendering has been done for this frame.
 Applications that wish to perform operations in the rendering loop,
 prior to any actual rendering may override this function.

 <p>
 Updates to live Geometry, Texture, and ImageComponent objects
 in the scene graph are not allowed from this method.

 <p>
 NOTE: Applications should <i>not</i> call this method.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="postRender()"><!-- --></A><H3>
postRender</H3>
<PRE>
public void <B>postRender</B>()</PRE>
<DL>
<DD>This routine is called by the Java 3D rendering loop after completing
 all rendering to the canvas for this frame and before the buffer swap.
 Applications that wish to perform operations in the rendering loop,
 following any actual rendering may override this function.

 <p>
 Updates to live Geometry, Texture, and ImageComponent objects
 in the scene graph are not allowed from this method.

 <p>
 NOTE: Applications should <i>not</i> call this method.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="postSwap()"><!-- --></A><H3>
postSwap</H3>
<PRE>
public void <B>postSwap</B>()</PRE>
<DL>
<DD>This routine is called by the Java 3D rendering loop after completing
 all rendering to the canvas, and all other canvases associated with
 this view, for this frame following the buffer swap.
 Applications that wish to perform operations at the very
 end of the rendering loop may override this function.
 In off-screen mode, all rendering is copied to the off-screen
 buffer before this method is called.

 <p>
 Updates to live Geometry, Texture, and ImageComponent objects
 in the scene graph are not allowed from this method.

 <p>
 NOTE: Applications should <i>not</i> call this method.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="renderField(int)"><!-- --></A><H3>
renderField</H3>
<PRE>
public void <B>renderField</B>(int&nbsp;fieldDesc)</PRE>
<DL>
<DD>This routine is called by the Java 3D rendering loop during the
 execution of the rendering loop.  It is called once for each
 field (i.e., once per frame on
 a mono system or once each for the right eye and left eye on a
 two-pass stereo system.  This is intended for use by applications that
 want to mix retained/compiled-retained mode rendering with some
 immediate mode rendering.  Applications that wish to perform
 operations during the rendering loop, may override this
 function.

 <p>
 Updates to live Geometry, Texture, and ImageComponent objects
 in the scene graph are not allowed from this method.

 <p>
 NOTE: Applications should <i>not</i> call this method.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fieldDesc</CODE> - field description, one of: FIELD_LEFT, FIELD_RIGHT or
 FIELD_ALL.  Applications that wish to work correctly in stereo mode
 should render the same image for both FIELD_LEFT and FIELD_RIGHT calls.
 If Java 3D calls the renderer with FIELD_ALL then the immediate mode
 rendering only needs to be done once.</DL>
</DD>
</DL>
<HR>

<A NAME="stopRenderer()"><!-- --></A><H3>
stopRenderer</H3>
<PRE>
public final void <B>stopRenderer</B>()</PRE>
<DL>
<DD>Stop the Java 3D renderer on this Canvas3D object.  If the
 Java 3D renderer is currently running, the rendering will be
 synchronized before being stopped.  No further rendering will be done
 to this canvas by Java 3D until the renderer is started again.
 In pure immediate mode this method should be called prior to adding
 this canvas to an active View object.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is in
 off-screen mode.</DL>
</DD>
</DL>
<HR>

<A NAME="startRenderer()"><!-- --></A><H3>
startRenderer</H3>
<PRE>
public final void <B>startRenderer</B>()</PRE>
<DL>
<DD>Start the Java 3D renderer on this Canvas3D object.  If the
 Java 3D renderer is not currently running, any rendering to other
 Canvas3D objects sharing the same View will be synchronized before this
 Canvas3D's renderer is (re)started.  When a Canvas3D is created, it is
 initially marked as being started.  This means that as soon as the
 Canvas3D is added to an active View object, the rendering loop will
 render the scene graph to the canvas.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isRendererRunning()"><!-- --></A><H3>
isRendererRunning</H3>
<PRE>
public final boolean <B>isRendererRunning</B>()</PRE>
<DL>
<DD>Retrieves the state of the renderer for this Canvas3D object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the state of the renderer<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isOffScreen()"><!-- --></A><H3>
isOffScreen</H3>
<PRE>
public boolean <B>isOffScreen</B>()</PRE>
<DL>
<DD>Retrieves a flag indicating whether this Canvas3D is an
 off-screen canvas.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if this Canvas3D is an off-screen canvas;
 <code>false</code> if this is an on-screen canvas.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOffScreenBuffer(javax.media.j3d.ImageComponent2D)"><!-- --></A><H3>
setOffScreenBuffer</H3>
<PRE>
public void <B>setOffScreenBuffer</B>(<A HREF="../../../javax/media/j3d/ImageComponent2D.html" title="class in javax.media.j3d">ImageComponent2D</A>&nbsp;buffer)</PRE>
<DL>
<DD>Sets the off-screen buffer for this Canvas3D.  The specified
 image is written into by the Java 3D renderer.  The size of the
 specified ImageComponent determines the size, in pixels, of
 this Canvas3D--the size inherited from Component is ignored.
 <p>
 NOTE: the size, physical width, and physical height of the associated
 Screen3D must be set explicitly prior to rendering.
 Failure to do so will result in an exception.
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - the image component that will be rendered into by
 subsequent calls to renderOffScreenBuffer. The image component must not
 be part of a live scene graph, nor may it subsequently be made part of a
 live scene graph while being used as an off-screen buffer; an
 IllegalSharingException is thrown in such cases. The buffer may be null,
 indicating that the previous off-screen buffer is released without a new
 buffer being set.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is not in
 off-screen mode.
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if an off-screen rendering
 is in process for this Canvas3D.
<DD><CODE><A HREF="../../../javax/media/j3d/IllegalSharingException.html" title="class in javax.media.j3d">IllegalSharingException</A></CODE> - if the specified ImageComponent2D
 is part of a live scene graph
<DD><CODE><A HREF="../../../javax/media/j3d/IllegalSharingException.html" title="class in javax.media.j3d">IllegalSharingException</A></CODE> - if the specified ImageComponent2D is
 being used by an immediate mode context, or by another Canvas3D as
 an off-screen buffer.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the image class of the specified
 ImageComponent2D is <i>not</i> ImageClass.BUFFERED_IMAGE.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the specified
 ImageComponent2D is in by-reference mode and its
 RenderedImage is null.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the ImageComponent2D format
 is <i>not</i> a 3-component format (e.g., FORMAT_RGB)
 or a 4-component format (e.g., FORMAT_RGBA).<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#renderOffScreenBuffer()"><CODE>renderOffScreenBuffer()</CODE></A>, 
<A HREF="../../../javax/media/j3d/Screen3D.html#setSize(int, int)"><CODE>Screen3D.setSize(int, int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Screen3D.html#setSize(java.awt.Dimension)"><CODE>Screen3D.setSize(Dimension)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Screen3D.html#setPhysicalScreenWidth(double)"><CODE>Screen3D.setPhysicalScreenWidth(double)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Screen3D.html#setPhysicalScreenHeight(double)"><CODE>Screen3D.setPhysicalScreenHeight(double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getOffScreenBuffer()"><!-- --></A><H3>
getOffScreenBuffer</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/ImageComponent2D.html" title="class in javax.media.j3d">ImageComponent2D</A> <B>getOffScreenBuffer</B>()</PRE>
<DL>
<DD>Retrieves the off-screen buffer for this Canvas3D.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current off-screen buffer for this Canvas3D.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is not in
 off-screen mode.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="renderOffScreenBuffer()"><!-- --></A><H3>
renderOffScreenBuffer</H3>
<PRE>
public void <B>renderOffScreenBuffer</B>()</PRE>
<DL>
<DD>Schedules the rendering of a frame into this Canvas3D's
 off-screen buffer.  The rendering is done from the point of
 view of the View object to which this Canvas3D has been added.
 No rendering is performed if this Canvas3D object has not been
 added to an active View.  This method does not wait for the rendering
 to actually happen.  An application that wishes to know when
 the rendering is complete must either subclass Canvas3D and
 override the <code>postSwap</code> method, or call
 <code>waitForOffScreenRendering</code>.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the off-screen buffer is null.
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is not in
 off-screen mode, or if either the width or the height of
 the associated Screen3D's size is <= 0, or if the associated
 Screen3D's physical width or height is <= 0.
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if an off-screen rendering
 is already in process for this Canvas3D or if the Java 3D renderer
 is stopped.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#setOffScreenBuffer(javax.media.j3d.ImageComponent2D)"><CODE>setOffScreenBuffer(javax.media.j3d.ImageComponent2D)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Screen3D.html#setSize(int, int)"><CODE>Screen3D.setSize(int, int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Screen3D.html#setSize(java.awt.Dimension)"><CODE>Screen3D.setSize(Dimension)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Screen3D.html#setPhysicalScreenWidth(double)"><CODE>Screen3D.setPhysicalScreenWidth(double)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Screen3D.html#setPhysicalScreenHeight(double)"><CODE>Screen3D.setPhysicalScreenHeight(double)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Canvas3D.html#waitForOffScreenRendering()"><CODE>waitForOffScreenRendering()</CODE></A>, 
<A HREF="../../../javax/media/j3d/Canvas3D.html#postSwap()"><CODE>postSwap()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="waitForOffScreenRendering()"><!-- --></A><H3>
waitForOffScreenRendering</H3>
<PRE>
public void <B>waitForOffScreenRendering</B>()</PRE>
<DL>
<DD>Waits for this Canvas3D's off-screen rendering to be done.
 This method will wait until the <code>postSwap</code> method of this
 off-screen Canvas3D has completed.  If this Canvas3D has not
 been added to an active view or if the renderer is stopped for this
 Canvas3D, then this method will return
 immediately.  This method must not be called from a render
 callback method of an off-screen Canvas3D.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is not in
 off-screen mode, or if this method is called from a render
 callback method of an off-screen Canvas3D.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#renderOffScreenBuffer()"><CODE>renderOffScreenBuffer()</CODE></A>, 
<A HREF="../../../javax/media/j3d/Canvas3D.html#postSwap()"><CODE>postSwap()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setOffScreenLocation(int, int)"><!-- --></A><H3>
setOffScreenLocation</H3>
<PRE>
public void <B>setOffScreenLocation</B>(int&nbsp;x,
                                 int&nbsp;y)</PRE>
<DL>
<DD>Sets the location of this off-screen Canvas3D.  The location is
 the upper-left corner of the Canvas3D relative to the
 upper-left corner of the corresponding off-screen Screen3D.
 The function of this method is similar to that of
 <code>Component.setLocation</code> for on-screen Canvas3D
 objects.  The default location is (0,0).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <i>x</i> coordinate of the upper-left corner of
 the new location.<DD><CODE>y</CODE> - the <i>y</i> coordinate of the upper-left corner of
 the new location.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is not in
 off-screen mode.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOffScreenLocation(java.awt.Point)"><!-- --></A><H3>
setOffScreenLocation</H3>
<PRE>
public void <B>setOffScreenLocation</B>(java.awt.Point&nbsp;p)</PRE>
<DL>
<DD>Sets the location of this off-screen Canvas3D.  The location is
 the upper-left corner of the Canvas3D relative to the
 upper-left corner of the corresponding off-screen Screen3D.
 The function of this method is similar to that of
 <code>Component.setLocation</code> for on-screen Canvas3D
 objects.  The default location is (0,0).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - the point defining the upper-left corner of the new
 location.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is not in
 off-screen mode.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOffScreenLocation()"><!-- --></A><H3>
getOffScreenLocation</H3>
<PRE>
public java.awt.Point <B>getOffScreenLocation</B>()</PRE>
<DL>
<DD>Retrieves the location of this off-screen Canvas3D.  The
 location is the upper-left corner of the Canvas3D relative to
 the upper-left corner of the corresponding off-screen Screen3D.
 The function of this method is similar to that of
 <code>Component.getLocation</code> for on-screen Canvas3D
 objects.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a new point representing the upper-left corner of the
 location of this off-screen Canvas3D.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is not in
 off-screen mode.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getOffScreenLocation(java.awt.Point)"><!-- --></A><H3>
getOffScreenLocation</H3>
<PRE>
public java.awt.Point <B>getOffScreenLocation</B>(java.awt.Point&nbsp;rv)</PRE>
<DL>
<DD>Retrieves the location of this off-screen Canvas3D and stores
 it in the specified Point object.  The location is the
 upper-left corner of the Canvas3D relative to the upper-left
 corner of the corresponding off-screen Screen3D.  The function
 of this method is similar to that of
 <code>Component.getLocation</code> for on-screen Canvas3D
 objects. This version of <code>getOffScreenLocation</code> is
 useful if the caller wants to avoid allocating a new Point
 object on the heap.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rv</CODE> - Point object into which the upper-left corner of the
 location of this off-screen Canvas3D is copied.
 If <code>rv</code> is null, a new Point is allocated.
<DT><B>Returns:</B><DD><code>rv</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is not in
 off-screen mode.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="swap()"><!-- --></A><H3>
swap</H3>
<PRE>
public void <B>swap</B>()</PRE>
<DL>
<DD>Synchronize and swap buffers on a double buffered canvas for
 this Canvas3D object.  This method should only be called if the
 Java 3D renderer has been stopped.  In the normal case, the renderer
 automatically swaps the buffer.
 This method calls the <code>flush(true)</code> methods of the
 associated 2D and 3D graphics contexts, if they have been allocated.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if the Java 3D renderer is
 running.
<DD><CODE>java.lang.IllegalStateException</CODE> - if this Canvas3D is in
 off-screen mode.<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#stopRenderer()"><CODE>stopRenderer()</CODE></A>, 
<A HREF="../../../javax/media/j3d/GraphicsContext3D.html#flush(boolean)"><CODE>GraphicsContext3D.flush(boolean)</CODE></A>, 
<A HREF="../../../javax/media/j3d/J3DGraphics2D.html#flush(boolean)"><CODE>J3DGraphics2D.flush(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setLeftManualEyeInImagePlate(javax.vecmath.Point3d)"><!-- --></A><H3>
setLeftManualEyeInImagePlate</H3>
<PRE>
public void <B>setLeftManualEyeInImagePlate</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Sets the position of the manual left eye in image-plate
 coordinates.  This value determines eye placement when a head
 tracker is not in use and the application is directly controlling
 the eye position in image-plate coordinates.
 In head-tracked mode or when the windowEyePointPolicy is
 RELATIVE_TO_FIELD_OF_VIEW or RELATIVE_TO_COEXISTENCE, this value
 is ignored.  When the
 windowEyepointPolicy is RELATIVE_TO_WINDOW only the Z value is
 used.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the new manual left eye position</DL>
</DD>
</DL>
<HR>

<A NAME="setRightManualEyeInImagePlate(javax.vecmath.Point3d)"><!-- --></A><H3>
setRightManualEyeInImagePlate</H3>
<PRE>
public void <B>setRightManualEyeInImagePlate</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Sets the position of the manual right eye in image-plate
 coordinates.  This value determines eye placement when a head
 tracker is not in use and the application is directly controlling
 the eye position in image-plate coordinates.
 In head-tracked mode or when the windowEyePointPolicy is
 RELATIVE_TO_FIELD_OF_VIEW or RELATIVE_TO_COEXISTENCE, this value
 is ignored.  When the
 windowEyepointPolicy is RELATIVE_TO_WINDOW only the Z value is
 used.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the new manual right eye position</DL>
</DD>
</DL>
<HR>

<A NAME="getLeftManualEyeInImagePlate(javax.vecmath.Point3d)"><!-- --></A><H3>
getLeftManualEyeInImagePlate</H3>
<PRE>
public void <B>getLeftManualEyeInImagePlate</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the position of the user-specified, manual left eye
 in image-plate
 coordinates and copies that value into the object provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the object that will receive the position</DL>
</DD>
</DL>
<HR>

<A NAME="getRightManualEyeInImagePlate(javax.vecmath.Point3d)"><!-- --></A><H3>
getRightManualEyeInImagePlate</H3>
<PRE>
public void <B>getRightManualEyeInImagePlate</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the position of the user-specified, manual right eye
 in image-plate
 coordinates and copies that value into the object provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the object that will receive the position</DL>
</DD>
</DL>
<HR>

<A NAME="getLeftEyeInImagePlate(javax.vecmath.Point3d)"><!-- --></A><H3>
getLeftEyeInImagePlate</H3>
<PRE>
public void <B>getLeftEyeInImagePlate</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the actual position of the left eye
 in image-plate
 coordinates and copies that value into the object provided.
 This value is a function of the windowEyepointPolicy, the tracking
 enable flag, and the manual left eye position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the object that will receive the position</DL>
</DD>
</DL>
<HR>

<A NAME="getRightEyeInImagePlate(javax.vecmath.Point3d)"><!-- --></A><H3>
getRightEyeInImagePlate</H3>
<PRE>
public void <B>getRightEyeInImagePlate</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the actual position of the right eye
 in image-plate
 coordinates and copies that value into the object provided.
 This value is a function of the windowEyepointPolicy, the tracking
 enable flag, and the manual right eye position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the object that will receive the position</DL>
</DD>
</DL>
<HR>

<A NAME="getCenterEyeInImagePlate(javax.vecmath.Point3d)"><!-- --></A><H3>
getCenterEyeInImagePlate</H3>
<PRE>
public void <B>getCenterEyeInImagePlate</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the actual position of the center eye
 in image-plate
 coordinates and copies that value into the object provided.
 The center eye is the fictional eye half-way between the left and
 right eye.
 This value is a function of the windowEyepointPolicy, the tracking
 enable flag, and the manual right and left eye positions.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the object that will receive the position<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#setMonoscopicViewPolicy(int)"><CODE>setMonoscopicViewPolicy(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getImagePlateToVworld(javax.media.j3d.Transform3D)"><!-- --></A><H3>
getImagePlateToVworld</H3>
<PRE>
public void <B>getImagePlateToVworld</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;t)</PRE>
<DL>
<DD>Retrieves the current ImagePlate coordinates to Virtual World
 coordinates transform and places it into the specified object.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - the Transform3D object that will receive the
 transform</DL>
</DD>
</DL>
<HR>

<A NAME="getPixelLocationInImagePlate(int, int, javax.vecmath.Point3d)"><!-- --></A><H3>
getPixelLocationInImagePlate</H3>
<PRE>
public void <B>getPixelLocationInImagePlate</B>(int&nbsp;x,
                                         int&nbsp;y,
                                         <A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;imagePlatePoint)</PRE>
<DL>
<DD>Computes the position of the specified AWT pixel value
 in image-plate
 coordinates and copies that value into the object provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the X coordinate of the pixel relative to the upper-left
 hand corner of the window.<DD><CODE>y</CODE> - the Y coordinate of the pixel relative to the upper-left
 hand corner of the window.<DD><CODE>imagePlatePoint</CODE> - the object that will receive the position in
 physical image plate coordinates (relative to the lower-left
 corner of the screen).</DL>
</DD>
</DL>
<HR>

<A NAME="getPixelLocationInImagePlate(javax.vecmath.Point2d, javax.vecmath.Point3d)"><!-- --></A><H3>
getPixelLocationInImagePlate</H3>
<PRE>
public void <B>getPixelLocationInImagePlate</B>(<A HREF="../../../javax/vecmath/Point2d.html" title="class in javax.vecmath">Point2d</A>&nbsp;pixelLocation,
                                         <A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;imagePlatePoint)</PRE>
<DL>
<DD>Computes the position of the specified AWT pixel value
 in image-plate
 coordinates and copies that value into the object provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pixelLocation</CODE> - the coordinates of the pixel relative to
 the upper-left hand corner of the window.<DD><CODE>imagePlatePoint</CODE> - the object that will receive the position in
 physical image plate coordinates (relative to the lower-left
 corner of the screen).<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPixelLocationFromImagePlate(javax.vecmath.Point3d, javax.vecmath.Point2d)"><!-- --></A><H3>
getPixelLocationFromImagePlate</H3>
<PRE>
public void <B>getPixelLocationFromImagePlate</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;imagePlatePoint,
                                           <A HREF="../../../javax/vecmath/Point2d.html" title="class in javax.vecmath">Point2d</A>&nbsp;pixelLocation)</PRE>
<DL>
<DD>Projects the specified point from image plate coordinates
 into AWT pixel coordinates.  The AWT pixel coordinates are
 copied into the object provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>imagePlatePoint</CODE> - the position in
 physical image plate coordinates (relative to the lower-left
 corner of the screen).<DD><CODE>pixelLocation</CODE> - the object that will receive the coordinates
 of the pixel relative to the upper-left hand corner of the window.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getVworldProjection(javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getVworldProjection</H3>
<PRE>
public void <B>getVworldProjection</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;leftProjection,
                                <A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;rightProjection)</PRE>
<DL>
<DD>Copies the current Vworld projection transform for each eye
 into the specified Transform3D objects.  This transform takes
 points in virtual world coordinates and projects them into
 clipping coordinates, which are in the range [-1,1] in
 <i>X</i>, <i>Y</i>, and <i>Z</i> after clipping and perspective
 division.
 In monoscopic mode, the same projection transform will be
 copied into both the right and left eye Transform3D objects.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>leftProjection</CODE> - the Transform3D object that will receive
 a copy of the current projection transform for the left eye.<DD><CODE>rightProjection</CODE> - the Transform3D object that will receive
 a copy of the current projection transform for the right eye.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInverseVworldProjection(javax.media.j3d.Transform3D, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getInverseVworldProjection</H3>
<PRE>
public void <B>getInverseVworldProjection</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;leftInverseProjection,
                                       <A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;rightInverseProjection)</PRE>
<DL>
<DD>Copies the inverse of the current Vworld projection transform
 for each eye into the specified Transform3D objects.  This
 transform takes points in clipping coordinates, which are in
 the range [-1,1] in <i>X</i>, <i>Y</i>, and <i>Z</i> after
 clipping and perspective division, and transforms them into
 virtual world coordinates.
 In monoscopic mode, the same inverse projection transform will
 be copied into both the right and left eye Transform3D objects.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>leftInverseProjection</CODE> - the Transform3D object that will
 receive a copy of the current inverse projection transform for
 the left eye.<DD><CODE>rightInverseProjection</CODE> - the Transform3D object that will
 receive a copy of the current inverse projection transform for
 the right eye.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalWidth()"><!-- --></A><H3>
getPhysicalWidth</H3>
<PRE>
public double <B>getPhysicalWidth</B>()</PRE>
<DL>
<DD>Retrieves the physical width of this canvas window in meters.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the physical window width in meters.</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalHeight()"><!-- --></A><H3>
getPhysicalHeight</H3>
<PRE>
public double <B>getPhysicalHeight</B>()</PRE>
<DL>
<DD>Retrieves the physical height of this canvas window in meters.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the physical window height in meters.</DL>
</DD>
</DL>
<HR>

<A NAME="getVworldToImagePlate(javax.media.j3d.Transform3D)"><!-- --></A><H3>
getVworldToImagePlate</H3>
<PRE>
public void <B>getVworldToImagePlate</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;t)</PRE>
<DL>
<DD>Retrieves the current Virtual World coordinates to ImagePlate
 coordinates transform and places it into the specified object.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - the Transform3D object that will receive the
 transform</DL>
</DD>
</DL>
<HR>

<A NAME="getView()"><!-- --></A><H3>
getView</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/View.html" title="class in javax.media.j3d">View</A> <B>getView</B>()</PRE>
<DL>
<DD>Gets view that points to this Canvas3D.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>view object that points to this Canvas3D</DL>
</DD>
</DL>
<HR>

<A NAME="getStereoAvailable()"><!-- --></A><H3>
getStereoAvailable</H3>
<PRE>
public boolean <B>getStereoAvailable</B>()</PRE>
<DL>
<DD>Returns a status flag indicating whether or not stereo
 is available.
 This is equivalent to:
 <ul>
 <code>
 ((Boolean)queryProperties().
 get("stereoAvailable")).
 booleanValue()
 </code>
 </ul>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag indicating whether stereo is available</DL>
</DD>
</DL>
<HR>

<A NAME="setStereoEnable(boolean)"><!-- --></A><H3>
setStereoEnable</H3>
<PRE>
public void <B>setStereoEnable</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Turns stereo on or off.  Note that this attribute is used
 only when stereo is available.  Enabling stereo on a Canvas3D
 that does not support stereo has no effect.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - enables or disables the display of stereo<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#queryProperties()"><CODE>queryProperties()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getStereoEnable()"><!-- --></A><H3>
getStereoEnable</H3>
<PRE>
public boolean <B>getStereoEnable</B>()</PRE>
<DL>
<DD>Returns a status flag indicating whether or not stereo
 is enabled.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag indicating whether stereo is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="setMonoscopicViewPolicy(int)"><!-- --></A><H3>
setMonoscopicViewPolicy</H3>
<PRE>
public void <B>setMonoscopicViewPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Specifies how Java 3D generates monoscopic view. If set to
 View.LEFT_EYE_VIEW, the view generated corresponds to the view as
 seen from the left eye. If set to View.RIGHT_EYE_VIEW, the view
 generated corresponds to the view as seen from the right
 eye. If set to View.CYCLOPEAN_EYE_VIEW, the view generated
 corresponds to the view as seen from the 'center eye', the
 fictional eye half-way between the left and right eye.  The
 default monoscopic view policy is View.CYCLOPEAN_EYE_VIEW.
 <p>
 NOTE: for backward compatibility with Java 3D 1.1, if this
 attribute is set to its default value of
 View.CYCLOPEAN_EYE_VIEW, the monoscopic view policy in the
 View object will be used.  An application should not use both
 the deprecated View method and this Canvas3D method at the same
 time.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - one of View.LEFT_EYE_VIEW, View.RIGHT_EYE_VIEW, or
 View.CYCLOPEAN_EYE_VIEW.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the specified
 policy is CYCLOPEAN_EYE_VIEW, the canvas is a stereo canvas,
 and the viewPolicy for the associated view is HMD_VIEW<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMonoscopicViewPolicy()"><!-- --></A><H3>
getMonoscopicViewPolicy</H3>
<PRE>
public int <B>getMonoscopicViewPolicy</B>()</PRE>
<DL>
<DD>Returns policy on how Java 3D generates monoscopic view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>policy one of View.LEFT_EYE_VIEW, View.RIGHT_EYE_VIEW or
 View.CYCLOPEAN_EYE_VIEW.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDoubleBufferAvailable()"><!-- --></A><H3>
getDoubleBufferAvailable</H3>
<PRE>
public boolean <B>getDoubleBufferAvailable</B>()</PRE>
<DL>
<DD>Returns a status flag indicating whether or not double
 buffering is available.
 This is equivalent to:
 <ul>
 <code>
 ((Boolean)queryProperties().
 get("doubleBufferAvailable")).
 booleanValue()
 </code>
 </ul>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag indicating whether double buffering is available.</DL>
</DD>
</DL>
<HR>

<A NAME="setDoubleBufferEnable(boolean)"><!-- --></A><H3>
setDoubleBufferEnable</H3>
<PRE>
public void <B>setDoubleBufferEnable</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Turns double buffering on or off.  If double buffering
 is off, all drawing is to the front buffer and no buffer swap
 is done between frames. It should be stressed that running
 Java 3D with double buffering disabled is not recommended.
 Enabling double buffering on a Canvas3D
 that does not support double buffering has no effect.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - enables or disables double buffering.<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#queryProperties()"><CODE>queryProperties()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDoubleBufferEnable()"><!-- --></A><H3>
getDoubleBufferEnable</H3>
<PRE>
public boolean <B>getDoubleBufferEnable</B>()</PRE>
<DL>
<DD>Returns a status flag indicating whether or not double
 buffering is enabled.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag indicating if double buffering is enabled.</DL>
</DD>
</DL>
<HR>

<A NAME="getSceneAntialiasingAvailable()"><!-- --></A><H3>
getSceneAntialiasingAvailable</H3>
<PRE>
public boolean <B>getSceneAntialiasingAvailable</B>()</PRE>
<DL>
<DD>Returns a status flag indicating whether or not scene
 antialiasing is available.
 This is equivalent to:
 <ul>
 <code>
 ((Boolean)queryProperties().
 get("sceneAntialiasingAvailable")).
 booleanValue()
 </code>
 </ul>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag indicating whether scene antialiasing is available.</DL>
</DD>
</DL>
<HR>

<A NAME="isShadingLanguageSupported(int)"><!-- --></A><H3>
isShadingLanguageSupported</H3>
<PRE>
public boolean <B>isShadingLanguageSupported</B>(int&nbsp;shadingLanguage)</PRE>
<DL>
<DD>Returns a flag indicating whether or not the specified shading
 language is supported. A ShaderError will be generated if an
 unsupported shading language is used.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shadingLanguage</CODE> - the shading language being queried, one of:
 <code>Shader.SHADING_LANGUAGE_GLSL</code> or
 <code>Shader.SHADING_LANGUAGE_CG</code>.
<DT><B>Returns:</B><DD>true if the specified shading language is supported,
 false otherwise.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="queryProperties()"><!-- --></A><H3>
queryProperties</H3>
<PRE>
public final java.util.Map <B>queryProperties</B>()</PRE>
<DL>
<DD>Returns a read-only Map object containing key-value pairs that define
 various properties for this Canvas3D.  All of the keys are
 String objects.  The values are key-specific, but most will be
 Boolean, Integer, Float, Double, or String objects.

 <p>
 The currently defined keys are:

 <p>
 <ul>
 <table BORDER=1 CELLSPACING=1 CELLPADDING=1>
 <tr>
 <td><b>Key (String)</b></td>
 <td><b>Value Type</b></td>
 </tr>
 <tr>
 <td><code>shadingLanguageCg</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>shadingLanguageGLSL</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>doubleBufferAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>stereoAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>sceneAntialiasingAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>sceneAntialiasingNumPasses</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>stencilSize</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>texture3DAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureColorTableSize</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureLodRangeAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureLodOffsetAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureWidthMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureHeightMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureBoundaryWidthMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureEnvCombineAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureCombineDot3Available</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureCombineSubtractAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureCoordSetsMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureUnitStateMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureImageUnitsMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureImageUnitsVertexMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureImageUnitsCombinedMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>textureCubeMapAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureDetailAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureSharpenAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureFilter4Available</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>textureAnisotropicFilterDegreeMax</code></td>
 <td>Float</td>
 </tr>
 <tr>
 <td><code>textureNonPowerOfTwoAvailable</code></td>
 <td>Boolean</td>
 </tr>
 <tr>
 <td><code>vertexAttrsMax</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>compressedGeometry.majorVersionNumber</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>compressedGeometry.minorVersionNumber</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>compressedGeometry.minorMinorVersionNumber</code></td>
 <td>Integer</td>
 </tr>
 <tr>
 <td><code>native.version</code></td>
 <td>String</td>
 </tr>
 </table>
 </ul>

 <p>
 The descriptions of the values returned for each key are as follows:

 <p>
 <ul>
 <li>
 <code>shadingLanguageCg</code>
 <ul>
 A Boolean indicating whether or not Cg shading Language
 is available for this Canvas3D. 
 </ul>
 </li>

 <li>
 <code>shadingLanguageGLSL</code>
 <ul>
 A Boolean indicating whether or not GLSL shading Language
 is available for this Canvas3D.     
 </ul>
 </li>

 <li>
 <code>doubleBufferAvailable</code>
 <ul>
 A Boolean indicating whether or not double buffering
 is available for this Canvas3D.  This is equivalent to
 the getDoubleBufferAvailable method.  If this flag is false,
 the Canvas3D will be rendered in single buffer mode; requests
 to enable double buffering will be ignored.
 </ul>
 </li>

 <li>
 <code>stereoAvailable</code>
 <ul>
 A Boolean indicating whether or not stereo
 is available for this Canvas3D.  This is equivalent to
 the getStereoAvailable method.  If this flag is false,
 the Canvas3D will be rendered in monoscopic mode; requests
 to enable stereo will be ignored.
 </ul>
 </li>

 <li>
 <code>sceneAntialiasingAvailable</code>
 <ul>
 A Boolean indicating whether or not scene antialiasing
 is available for this Canvas3D.  This is equivalent to
 the getSceneAntialiasingAvailable method.  If this flag is false,
 requests to enable scene antialiasing will be ignored.
 </ul>
 </li>

 <li>
 <code>sceneAntialiasingNumPasses</code>
 <ul>
 An Integer indicating the number of passes scene antialiasing
 requires to render a single frame for this Canvas3D.  
 If this value is zero, scene antialiasing is not supported.  
 If this value is one, multisampling antialiasing is used.
 Otherwise, the number indicates the number of rendering passes
 needed. 
 </ul>
 </li>

 <li>
 <code>stencilSize</code>
 <ul>
 An Integer indicating the number of stencil bits that are available
 for this Canvas3D. 
 </ul>
 </li>

 <li>
 <code>texture3DAvailable</code>
 <ul>
 A Boolean indicating whether or not 3D Texture mapping
 is available for this Canvas3D.  If this flag is false,
 3D texture mapping is either not supported by the underlying
 rendering layer or is otherwise unavailable for this
 particular Canvas3D.  All use of 3D texture mapping will be
 ignored in this case.
 </ul>
 </li>

 <li>
 <code>textureColorTableSize</code>
 <ul>
 An Integer indicating the maximum size of the texture color
 table for this Canvas3D.  If the size is 0, the texture
 color table is either not supported by the underlying rendering
 layer or is otherwise unavailable for this particular
 Canvas3D.  An attempt to use a texture color table larger than
 textureColorTableSize will be ignored; no color lookup will be
 performed.
 </ul>
 </li>

 <li>
 <code>textureLodRangeAvailable</code>
 <ul>
 A Boolean indicating whether or not setting only a subset of mipmap
 levels and setting a range of texture LOD are available for this 
 Canvas3D. 
 If it indicates false, setting a subset of mipmap levels and
 setting a texture LOD range are not supported by the underlying 
 rendering layer, and an attempt to set base level, or maximum level,
 or minimum LOD, or maximum LOD will be ignored. In this case,
 images for all mipmap levels must be defined for the texture to be
 valid.
 </ul>
 </li>

 <li>
 <code>textureLodOffsetAvailable</code>
 <ul>
 A Boolean indicating whether or not setting texture LOD offset is
 available for this Canvas3D. If it indicates false, setting
 texture LOD offset is not supported by the underlying rendering 
 layer, and an attempt to set the texture LOD offset will be ignored.
 </ul>
 </li>

 <li>
 <code>textureWidthMax</code>
 <ul>
 An Integer indicating the maximum texture width supported by
 this Canvas3D. If the width of a texture exceeds the maximum texture
 width for a Canvas3D, then the texture will be effectively disabled
 for that Canvas3D. 
 </ul>
 </li>

 <li>
 <code>textureHeightMax</code>
 <ul>
 An Integer indicating the maximum texture height supported by
 this Canvas3D. If the height of a texture exceeds the maximum texture
 height for a Canvas3D, then the texture will be effectively disabled
 for that Canvas3D.
 </ul>
 </li>

 <li>
 <code>textureBoundaryWidthMax</code>
 <ul>
 An Integer indicating the maximum texture boundary width
 supported by the underlying rendering layer for this Canvas3D. If 
 the maximum supported texture boundary width is 0, then texture
 boundary is not supported by the underlying rendering layer.
 An attempt to specify a texture boundary width > the 
 textureBoundaryWidthMax will effectively disable the texture.
 </ul>
 </li>

 <li>
 <code>textureEnvCombineAvailable</code>
 <ul>
 A Boolean indicating whether or not texture environment combine
 operation is supported for this Canvas3D. If it indicates false,
 then texture environment combine is not supported by the
 underlying rendering layer, and an attempt to specify COMBINE
 as the texture mode will be ignored. The texture mode in effect
 will be REPLACE.
 </ul>
 </li>

 <li>
 <code>textureCombineDot3Available</code>
 <ul>
 A Boolean indicating whether or not texture combine mode 
 COMBINE_DOT3 is
 supported for this Canvas3D. If it indicates false, then
 texture combine mode COMBINE_DOT3 is not supported by
 the underlying rendering layer, and an attempt to specify
 COMBINE_DOT3 as the texture combine mode will be ignored.
 The texture combine mode in effect will be COMBINE_REPLACE.
 </ul>
 </li>

 <li>
 <code>textureCombineSubtractAvailable</code>
 <ul>
 A Boolean indicating whether or not texture combine mode 
 COMBINE_SUBTRACT is
 supported for this Canvas3D. If it indicates false, then
 texture combine mode COMBINE_SUBTRACT is not supported by
 the underlying rendering layer, and an attempt to specify
 COMBINE_SUBTRACT as the texture combine mode will be ignored.
 The texture combine mode in effect will be COMBINE_REPLACE.
 </ul>
 </li>

 <li>
 <code>textureCoordSetsMax</code>
 <ul>
 An Integer indicating the maximum number of texture coordinate sets
 supported by the underlying rendering layer.
 </ul>
 </li>

 <li>
 <code>textureUnitStateMax</code>
 <ul>
 An Integer indicating the maximum number of fixed-function texture units
 supported by the underlying rendering layer. If the number of
 application-sepcified texture unit states exceeds the maximum number
 for a Canvas3D, and the fixed-function rendering pipeline is used, then
 the texture will be effectively disabled for that Canvas3D.
 </ul>
 </li>

 <li>
 <code>textureImageUnitsMax</code>
 <ul>
 An Integer indicating the maximum number of texture image units
 that can be accessed by the fragment shader when programmable shaders
 are used.
 </ul>
 </li>

 <li>
 <code>textureImageUnitsVertexMax</code>
 <ul>
 An Integer indicating the maximum number of texture image units
 that can be accessed by the vertex shader when programmable shaders
 are used.
 </ul>
 </li>

 <li>
 <code>textureImageUnitsCombinedMax</code>
 <ul>
 An Integer indicating the combined maximum number of texture image units
 that can be accessed by the vertex shader and the fragment shader when
 programmable shaders are used.
 </ul>
 </li>

 <li>
 <code>textureCubeMapAvailable</code>
 <ul>
 A Boolean indicating whether or not texture cube map is supported
 for this Canvas3D. If it indicates false, then texture cube map
 is not supported by the underlying rendering layer, and an attempt
 to specify NORMAL_MAP or REFLECTION_MAP as the texture generation
 mode will be ignored. The texture generation mode in effect will
 be SPHERE_MAP.
 </ul>
 </li>

 <li>
 <code>textureDetailAvailable</code>
 <ul>
 A Boolean indicating whether or not detail texture is supported
 for this Canvas3D. If it indicates false, then detail texture is
 not supported by the underlying rendering layer, and an attempt
 to specify LINEAR_DETAIL, LINEAR_DETAIL_ALPHA or
 LINEAR_DETAIL_RGB as the texture magnification filter mode will
 be ignored. The texture magnification filter mode in effect will
 be BASE_LEVEL_LINEAR.
 As of Java 3D 1.5, this property is always false.
 </ul>
 </li>

 <li>
 <code>textureSharpenAvailable</code>
 <ul>
 A Boolean indicating whether or not sharpen texture is supported
 for this Canvas3D. If it indicates false, then sharpen texture
 is not supported by the underlying rendering layer, and an attempt
 to specify LINEAR_SHARPEN, LINEAR_SHARPEN_ALPHA or
 LINEAR_SHARPEN_RGB as the texture magnification filter mode
 will be ignored. The texture magnification filter mode in effect
 will be BASE_LEVEL_LINEAR.
 </ul>
 </li>

 <li>
 <code>textureFilter4Available</code>
 <ul>
 A Boolean indicating whether or not filter4 is supported for this
 Canvas3D. If it indicates flase, then filter4 is not supported
 by the underlying rendering layer, and an attempt to specify
 FILTER_4 as the texture minification filter mode or texture
 magnification filter mode will be ignored. The texture filter mode
 in effect will be BASE_LEVEL_LINEAR.
 </ul>
 </li>

 <li>
 <code>textureAnisotropicFilterDegreeMax</code>
 <ul>
 A Float indicating the maximum degree of anisotropic filter
 available for this Canvas3D. If it indicates 1.0, setting
 anisotropic filter is not supported by the underlying rendering
 layer, and an attempt to set anisotropic filter degree will be ignored.
 </ul>
 </li>

 <li>
 <code>textureNonPowerOfTwoAvailable</code>
 <ul>
 A Boolean indicating whether or not texture dimensions that are
 not powers of two are supported for
 for this Canvas3D. If it indicates false, then textures with
 non power of two sizes will be ignored. Set the property 
 j3d.textureEnforcePowerOfTwo to revert to the pre-1.5 behavior
 of throwing exceptions for non power of two textures.
 </ul>
 </li>

 <li>
 <code>vertexAttrsMax</code>
 <ul>
 An Integer indicating the maximum number of vertex attributes
 supported by the underlying rendering layer. This is in addition to
 the vertex coordinate (position), color, normal, and so forth.
 </ul>
 </li>

 <li>
 <code>compressedGeometry.majorVersionNumber</code><br>
 <code>compressedGeometry.minorVersionNumber</code><br>
 <code>compressedGeometry.minorMinorVersionNumber</code>
 <ul>
 Integers indicating the major, minor, and minor-minor
 version numbers, respectively, of the version of compressed
 geometry supported by this version of Java 3D.
 </ul>
 </li>

 <li>
 <code>native.version</code>
 <ul>
 A String indicating the version number of the native graphics
 library.  The format of this string is defined by the native
 library.
 </ul>
 </li>
 </ul>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the properties of this Canavs3D<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSize()"><!-- --></A><H3>
getSize</H3>
<PRE>
public java.awt.Dimension <B>getSize</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getSize</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSize(java.awt.Dimension)"><!-- --></A><H3>
getSize</H3>
<PRE>
public java.awt.Dimension <B>getSize</B>(java.awt.Dimension&nbsp;rv)</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getSize</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLocationOnScreen()"><!-- --></A><H3>
getLocationOnScreen</H3>
<PRE>
public java.awt.Point <B>getLocationOnScreen</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getLocationOnScreen</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getX()"><!-- --></A><H3>
getX</H3>
<PRE>
public int <B>getX</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getX</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getY()"><!-- --></A><H3>
getY</H3>
<PRE>
public int <B>getY</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getY</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getWidth()"><!-- --></A><H3>
getWidth</H3>
<PRE>
public int <B>getWidth</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getWidth</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getHeight()"><!-- --></A><H3>
getHeight</H3>
<PRE>
public int <B>getHeight</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getHeight</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLocation(java.awt.Point)"><!-- --></A><H3>
getLocation</H3>
<PRE>
public java.awt.Point <B>getLocation</B>(java.awt.Point&nbsp;rv)</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getLocation</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLocation()"><!-- --></A><H3>
getLocation</H3>
<PRE>
public java.awt.Point <B>getLocation</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getLocation</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBounds()"><!-- --></A><H3>
getBounds</H3>
<PRE>
public java.awt.Rectangle <B>getBounds</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getBounds</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getBounds(java.awt.Rectangle)"><!-- --></A><H3>
getBounds</H3>
<PRE>
public java.awt.Rectangle <B>getBounds</B>(java.awt.Rectangle&nbsp;rv)</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>getBounds</CODE> in class <CODE>java.awt.Component</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/media/j3d/BranchGroup.html" title="class in javax.media.j3d"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/media/j3d/CapabilityNotSetException.html" title="class in javax.media.j3d"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/media/j3d/Canvas3D.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Canvas3D.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_classes_inherited_from_class_java.awt.Canvas">NESTED</A>&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1">Copyright (c) 2006 Sun Microsystems, Inc. All rights reserved. Use is subject to <a href="../../../LICENSE-SPEC.html">license terms</a>.
</BODY>
</HTML>
