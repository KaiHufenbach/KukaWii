<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Wed Dec 13 16:20:28 PST 2006 -->
<TITLE>
View (Java 3D 1.5.0)
</TITLE>

<META NAME="keywords" CONTENT="javax.media.j3d.View class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="View (Java 3D 1.5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/media/j3d/TriangleStripArray.html" title="class in javax.media.j3d"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/media/j3d/ViewPlatform.html" title="class in javax.media.j3d"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/media/j3d/View.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="View.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.media.j3d</FONT>
<BR>
Class View</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>javax.media.j3d.View</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>View</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
The View object contains all parameters needed in rendering a
 three dimensional scene from one viewpoint.  A view contains a list
 of Canvas3D objects that the view is rendered into.  It exists outside
 of the scene graph, but attaches to a ViewPlatform leaf node object
 in the scene graph.  It also contains a reference to a PhysicalBody
 and a PhysicalEnvironment object.
 <P>
 The View object is the main Java 3D object for controlling the
 Java 3D viewing model. All of the components that specify the
 view transform used to render to the 3D canvases are either contained
 in the View object or in objects that are referenced by the View
 object.
 <P>
 Java 3D allows applications to specify multiple simultaneously active
 View objects, each controlling its own set of canvases.
 <P>
 The Java 3D View object has several instance variables and methods,
 but most are calibration variables or user-helping functions. The
 viewing policies defined by the View object are described below.
 <P>
 <b>Policies</b><P>

 The View object defines the following policies:<P>
 <UL>
 <LI>View policy - informs Java 3D whether it should generate
 the view using the head-tracked system of transformations or the
 head-mounted system of transformations. These policies are attached
 to the Java 3D View object. There are two view policies:</LI><P>
 <UL>
 <LI>SCREEN_VIEW - specifies that Java 3D should compute a new
 viewpoint using the sequence of transforms appropriate to screen-based
 head-tracked display environments (fish-tank VR/portals/VR-desks).
 This is the default setting.</LI><P>
 <LI>HMD_VIEW - specifies that Java 3D should compute a new viewpoint
 using the sequence of transforms appropriate to head mounted display
 environments. This policy is not available in compatibility mode
 (see the setCompatibilityModeEnable method description).</LI><P>
 </UL>
 <LI>Projection policy - specifies whether Java 3D should generate
 a parallel projection or a perspective projection. This policy
 is attached to the Java 3D View object. There are two projection
 policies:</LI><P>
 <UL>
 <LI>PARALLEL_PROJECTION - specifies that a parallel projection
 transform is computed.</LI><P>
 <LI>PERSPECTIVE_PROJECTION - specifies that a perspective projection
 transform is computed. This is the default policy.</LI><P>
 </UL>
 <LI>Screen scale policy - specifies where the screen scale comes from.
 There are two screen scale policies:</LI><P>
 <UL>
 <LI>SCALE_SCREEN_SIZE - specifies that the scale is derived from the
 physical screen according to the following formula (this is the
 default mode):</LI>
 <UL>
 <code>screenScale = physicalScreenWidth / 2.0</code><P>
 </UL>
 <LI>SCALE_EXPLICIT - pecifies that the scale is taken directly from
 the user-provided <code>screenScale</code> attribute (see the
 setScreenScale method description).</LI><P>
 </UL>
 <LI>Window resize policy - specifies how Java 3D modifies the view
 when users resize windows. When users resize or move windows,
 Java 3D can choose to think of the window as attached either to
 the physical world or to the virtual world. The window resize
 policy allows an application to specify how the
 view model will handle resizing requests.
 There are two window resize policies:</LI><P>
 <UL>
 <LI>VIRTUAL_WORLD - implies that the original image remains the
 same size on the screen but the user sees more or less of the
 virtual world depending on whether the window grew or shrank
 in size.</LI><P>
 <LI>PHYSICAL_WORLD - implies that the original image continues
 to fill the window in the same way using more or less pixels
 depending on whether the window grew or shrank in size.</LI><P>
 </UL>
 <LI>Window movement policy - specifies what part of the virtual
 world Java 3D draws as a function of window placement on the screen.
 There are two window movement policies:</LI><P>
 <UL>
 <LI>VIRTUAL_WORLD - implies that the image seen in the window
 changes as the position of the window shifts on the screen.
 (This mode acts as if the window were a window into the virtual
 world.)</LI><P>
 <LI>PHYSICAL_WORLD - implies that the image seen in the window
 remains the same no matter where the user positions the window
 on the screen.</LI><P>
 </UL>
 <LI>Window eyepoint policy - comes into effect in a non-head-tracked
 environment. The policy tells Java 3D how to construct a new view
 frustum based on changes in the field of view and in the Canvas3D's
 location on the screen. The policy only comes into effect when the
 application changes a parameter that can change the placement of the
 eyepoint relative to the view frustum.
 There are three window eyepoint policies:</LI><P>
 <UL>
 <LI>RELATIVE_TO_SCREEN - tells Java 3D to interpret the eye's position
 relative to the entire screen. No matter where an end user moves a
 window (a Canvas3D), Java 3D continues to interpret the eye's position
 relative to the screen. This implies that the view frustum changes shape
 whenever an end user moves the location of a window on the screen.
 In this mode, the field of view is read-only.</LI><P>
 <LI>RELATIVE_TO_WINDOW - specifies that Java 3D should interpret the
 eye's position information relative to the window (Canvas3D). No matter
 where an end user moves a window (a Canvas3D), Java 3D continues to
 interpret the eye's position relative to that window. This implies
 that the frustum remains the same no matter where the end user
 moves the window on the screen. In this mode, the field of view
 is read-only.</LI><P>
 <LI>RELATIVE_TO_FIELD_OF_VIEW - tells Java 3D that it should
 modify the eyepoint position so it is located at the appropriate
 place relative to the window to match the specified field of view.
 This implies that the view frustum will change whenever the
 application changes the field of view. In this mode, the eye
 position is read-only. This is the default setting.</LI><P>
 <LI>RELATIVE_TO_COEXISTENCE - tells Java 3D to interpret the eye's
 position in coexistence coordinates. In this mode, the eye position
 is taken from the view (rather than the Canvas3D) and transformed from
 coexistence coordinates to image plate coordinates for each
 Canvas3D.  The resulting eye position is relative to the screen. As
 in RELATIVE_TO_SCREEN mode, this implies that the view frustum
 changes shape whenever an end user moves the location of a window
 on the screen.  In this mode, the field of view is
 read-only.</LI><P>
 </UL>
 <LI>Front and back clip policies - specifies how Java 3D
 interprets clipping distances to both the near and far clip
 planes. The policies can contain one of four values specifying
 whether a distance measurement should be interpreted in
 the physical or the virtual world and whether that distance
 measurement should be interpreted relative to the physical
 eyepoint or the physical screen.
 The front and back clip policies
 are specified separately. The front clip policy determines
 where Java 3D places the front clipping plane. The back clip
 policy determines where Java 3D places the back clipping plane.
 The values for both front and back clipping planes are:</LI><P>
 <UL>
 <LI>VIRTUAL_EYE - specifies that the associated distance is from
 the eye and in units of virtual distance.</LI><P>
 <LI>PHYSICAL_EYE - specifies that the associated distance is from
 the eye and in units of physical distance (in meters).
 This is the default policy for both front and back clipping.</LI><P>
 <LI>VIRTUAL_SCREEN  - specifies that the associated distance is
 from the screen and in units of virtual distance. </LI><P>
 <LI>PHYSICAL_SCREEN - specifies that the associated distance is
 from the screen and in units of physical distance (in meters).
 </LI><P>
 </UL>
 <LI>Visibility policy - specifies how visible and invisible objects
 are drawn. There are three visibility policies:</LI><P>
 <UL>
 <LI>VISIBILITY_DRAW_VISIBLE - only visible objects are drawn
 (this is the default).</LI><P>
 <LI>VISIBILITY_DRAW_INVISIBLE - only invisible objects are drawn.</LI><P>
 <LI>VISIBILITY_DRAW_ALL - both visible and invisible
 objects are drawn. </LI><P>
 </UL>
 <LI>Transparency sorting policy - specifies whether and how
 transparent objects are sorted.  Sorting multiple transparent
 objects is necessary to avoid artifacts caused by overlapping
 transparent objects.  There are two transparency sorting
 policies:</LI><P>
 <UL>
 <LI>TRANSPARENCY_SORT_NONE - no depth sorting of transparent
 objects is performed (this is the default).  Transparent objects
 are drawn after opaque objects, but are not sorted from back to
 front.</LI><P>
 <LI>TRANSPARENCY_SORT_GEOMETRY - transparent objects are
 depth-sorted on a per-geometry basis.  Each geometry object of each
 transparent Shape3D node is drawn from back to front.  Note that
 this policy will not split geometry into smaller pieces, so
 intersecting or intertwined objects may not be sorted
 correctly.  The method used for determining which geometry is closer
 is implementation dependent.</LI><P>
 </UL>
 </UL>
 <b>Projection and Clip Parameters</b><P>
 The projection and clip parameters determine the view model's
 field of view and the front and back clipping distances.<P>
 <UL>
 <LI>Field of view - specifies the view model's horizontal
 field of view in radians, when in the default non-head-tracked
 mode. This value is ignored when the view model is operating
 in head-tracked mode, or when the Canvas3D's window eyepoint
 policy is set to a value other than the default setting of
 RELATIVE_TO_FIELD_OF_VIEW.</LI><P>
 <LI>Front clip distance - specifies the distance away from the
 clip origin, specified by the front clip policy variable, in
 the direction of gaze where objects stop disappearing. Objects
 closer than the clip origin (eye or screen)
 plus the front clip distance are not drawn. Measurements are
 done in the space (physical or virtual) that is specified by
 the associated front clip policy parameter.</LI><P>
 <LI>Back clip distance - specifies the distance away from the
 clip origin (specified by the back clip policy variable) in the
 direction of gaze where objects begin disappearing. Objects
 farther away from the clip origin (eye or
 screen) plus the back clip distance are not drawn.
 Measurements are done in the space (physical or virtual) that
 is specified by the associated back clip policy
 parameter. The View object's back clip distance is ignored
 if the scene graph contains an active Clip leaf node.</LI><P>
 There are several considerations to take into account when
 choosing values for the front and back clip distances.<P>
 <UL>
 <LI>The front clip distance must be greater than 0.0 in physical
 eye coordinates.</LI><P>
 <LI>The front clipping plane must be in front of the back clipping
 plane, that is, the front clip distance must be less than the
 back clip distance in physical eye coordinates.</LI><P>
 <LI>The front and back clip distances, in physical eye coordinates,
 must be less than the largest positive single-precision floating
 point value, Float.MAX_VALUE. In practice, since these physical
 eye coordinate distances are in meters, the values
 should be much less than that.</LI><P>
 <LI>The ratio of the back distance divided by the front distance,
 in physical eye coordinates, affects Z-buffer precision. This ratio
 should be less than about 3000 to accommodate 16-bit Z-buffers.
 Values of 100 to less than 1000 will produce better results.</LI><P>
 </UL>
 Violating any of the above rules will result in undefined behavior.
 In many cases, no picture will be drawn.<P>
 </UL>
 <b>Frame Start Time, Duration, and Number</b><P>

 There are five methods used to get information about system
 execution and performance:<P>
 <UL>
 <code>getCurrentFrameStartTime</code> returns the time at which 
 the most recent rendering frame started.<P>
 <code>getLastFrameDuration</code> returns the duration, in milliseconds, of
 the most recently completed rendering frame.<P>
 <code>getFrameNumber</code> returns the frame number for this view.<P>
 <code>getMaxFrameStartTimes</code> retrieves the implementation-dependent
 maximum number of frames whose start times will be recorded by
 the system.<P>
 <code>getFrameStartTimes</code> copies the last k frame start time values
 into the user-specified array.<P>
 </UL>
 <b>View Traversal and Behavior Scheduling</b><P>
 The following methods control the traversal, the rendering, and
 the execution of the behavior scheduler for this view:<P>
 <UL>
 <code>startBehaviorScheduler</code> starts the behavior scheduler 
 running after it has been stopped.<P>
 <code>stopBehaviorScheduler</code> stops the behavior scheduler after all
 currently-scheduled behaviors are executed.<P>
 <code>isBehaviorSchedulerRunning</code> retrieves a flag that indicates
 whether the behavior scheduler is currently running.<P>
 <code>startView</code> starts traversing this view and starts the renderers
 associated with all canvases attached to this view.<P>
 <code>stopView</code> stops traversing this view after the current state of
 the scene graph is reflected on all canvases attached to this
 view.<P>
 <code>isViewRunning</code> returns a flag indicating whether the traverser
 is currently running on this view.<P>
 </UL>
 Note: The above six methods are heavy-weight methods intended
 for verification and image capture (recording). They are not
 intended to be used for flow control.<P>

 <b>Scene Antialiasing</b><P>

 The following methods set and retrieve the scene antialiasing
 flag. Scene antialiasing is either enabled or disabled for this
 view. If enabled, the entire scene will be antialiased on each
 canvas in which scene antialiasing is available. Scene
 antialiasing is disabled by default.<P>
 <UL>
 <code>setSceneAntialiasingEnable</code> sets the scene antialiasing flag.<P>
 <code>getSceneAntialiasingEnable</code> returns the scene antialiasing
 flag.<P>
 </UL>
 Note that line and point antialiasing are independent of scene 
 antialiasing. If antialiasing is enabled for lines and points, 
 the lines and points will be antialiased prior to scene antialiasing.
 If scene antialiasing is disabled, antialiased lines and points will
 still be antialiased.
 <p>
 <b>Note:</b> Scene antialiasing is ignored in pure immediate mode,
 but is supported in mixed-immediate mode.
 <p>
 <b>Depth Buffer</b><P>

 The following two methods enable and disable automatic freezing
 of the depth buffer for objects rendered during the transparent
 rendering pass (that is, objects rendered using alpha blending)
 for this view. If enabled, depth buffer writes are disabled
 during the transparent rendering pass regardless of the value
 of the depth-buffer-write-enable flag in the RenderingAttributes
 object for a particular node. This flag is enabled by default.<P>
 <UL>
 <code>setDepthBufferFreezeTransparent</code> enables depth buffer freezing.<P>
 <code>getDepthBufferFreezeTransparent</code> retrieves the depth buffer
 flag.<P>
 </UL>
 Transparent objects include BLENDED transparent primitives
 and antialiased lines
 and points. Transparent objects do not include opaque objects
 or primitives rendered with SCREEN_DOOR transparency.<p>

 <b>Sensors</b><P>

 The following methods retrieve the sensor's location in the
 virtual world:<P>
 <UL>
 <code>getSensorToVworld</code> takes the sensor's last reading and
 generates a sensor-to-vworld coordinate system transform. This
 Transform3D object takes points in that sensor's local coordinate
 system and transforms them into virtual world coordinates.<P>

 <code>getSensorHotSpotInVworld</code> retrieves the specified sensor's
 last hotspot location in virtual world coordinates.<P>
 </UL>

 <b>Compatibility Mode</b><P>

 A camera-based view model allows application programmers to think
 about the images displayed on the computer screen as if a virtual
 camera took those images. Such a view model allows application
 programmers to position and orient a virtual camera within a
 virtual scene, to manipulate some parameters of the virtual
 camera's lens (specify its field of view), and to specify the
 locations of the near and far clipping planes.<P>
 Java 3D allows applications to enable compatibility mode for
 room-mounted, non-head-tracked display environments, or to disable
 compatibility mode using the following methods. Camera-based
 viewing functions are only available in compatibility mode.<P>
 <UL>
 <code>setCompatibilityModeEnable</code> turns compatibility mode on or off.
 Compatibility mode is disabled by default.<P>
 <code>getCompatabilityModeEnable</code> returns the compatibility mode
 enable flag.<P>
 </UL>
 Use of these view-compatibility functions will disable some of
 Java 3D's view model features and limit the portability of Java
 3D programs. These methods are primarily intended to help
 jump-start porting of existing applications.<P>

 Setting the Viewing Transform<P>

 The View object provides the following compatibility-mode
 methods that operate on the viewing transform.<P>
 <UL>
 <code>setVpcToEc</code> a compatibility mode method that 
 specifies the ViewPlatform
 coordinates (VPC) to eye coordinates viewing transform.<P>
 <code>getVpcToEc</code> returns the VPC.<P>
 </UL>
 Setting the Projection Transform
 <p>
 The View object provides the following compatibility-mode
 methods that operate on the projection transform:<P>
 <UL>
 The <code>setLeftProjection</code> and <code>setRightProjection</code> 
 methods specify
 a viewing frustum for the left and right eye that transforms
 points in eye coordinates to clipping coordinates.<P>
 
 The <code>getLeftProjection</code> and <code>getRightProjection</code> 
 methods return
 the viewing frustum for the left and right eye.<P>
 </UL>

 <p>
 <b>Additional Information</b>
 <p>
 For more information, see the
 <a href="doc-files/intro.html">Introduction to the Java 3D API</a> and
 <a href="doc-files/ViewModel.html">View Model</a>
 documents.
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d"><CODE>Canvas3D</CODE></A>, 
<A HREF="../../../javax/media/j3d/PhysicalBody.html" title="class in javax.media.j3d"><CODE>PhysicalBody</CODE></A>, 
<A HREF="../../../javax/media/j3d/PhysicalEnvironment.html" title="class in javax.media.j3d"><CODE>PhysicalEnvironment</CODE></A>, 
<A HREF="../../../javax/media/j3d/ViewPlatform.html" title="class in javax.media.j3d"><CODE>ViewPlatform</CODE></A>, 
<A HREF="../../../javax/media/j3d/TransparencyAttributes.html" title="class in javax.media.j3d"><CODE>TransparencyAttributes</CODE></A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#CYCLOPEAN_EYE_VIEW">CYCLOPEAN_EYE_VIEW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that monoscopic view generated should be the view as seen
 from the 'center eye', the fictional eye half-way between the left and
 right eye.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#HMD_VIEW">HMD_VIEW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that the viewing environment for this view is a
 head-mounted display environment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#LEFT_EYE_VIEW">LEFT_EYE_VIEW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that monoscopic view generated should be the view as seen
 from the left eye.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#NOMINAL_FEET">NOMINAL_FEET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies a policy whereby the origin of physical or virtual
 coordinates is relative to the position of the nominal feet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#NOMINAL_HEAD">NOMINAL_HEAD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies a policy whereby the origin of physical or virtual
 coordinates is relative to the position of the nominal head.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#NOMINAL_SCREEN">NOMINAL_SCREEN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies a policy whereby the origin of physical or virtual
 coordinates is relative to the screen.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#PARALLEL_PROJECTION">PARALLEL_PROJECTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that Java 3D should generate a parallel projection matrix
 for this View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#PERSPECTIVE_PROJECTION">PERSPECTIVE_PROJECTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that Java 3D should generate a perspective projection matrix
 for this View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#PHYSICAL_EYE">PHYSICAL_EYE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that the associated distance is measured
 from the eye in meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#PHYSICAL_SCREEN">PHYSICAL_SCREEN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that the associated distance is measured
 from the screen in meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#PHYSICAL_WORLD">PHYSICAL_WORLD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy for resizing and moving windows.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#RELATIVE_TO_COEXISTENCE">RELATIVE_TO_COEXISTENCE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy for placing the eyepoint in non-head-tracked modes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#RELATIVE_TO_FIELD_OF_VIEW">RELATIVE_TO_FIELD_OF_VIEW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy for placing the eyepoint in non-head-tracked modes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#RELATIVE_TO_SCREEN">RELATIVE_TO_SCREEN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy for placing the eyepoint in non-head-tracked modes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#RELATIVE_TO_WINDOW">RELATIVE_TO_WINDOW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy for placing the eyepoint in non-head-tracked modes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#RIGHT_EYE_VIEW">RIGHT_EYE_VIEW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that monoscopic view generated should be the view as seen
 from the right eye.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#SCALE_EXPLICIT">SCALE_EXPLICIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that the screen scale for this view is taken directly
 from the user-provided screenScale parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#SCALE_SCREEN_SIZE">SCALE_SCREEN_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that the screen scale for this view is derived from
 the physical screen size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#SCREEN_VIEW">SCREEN_VIEW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that the viewing environment for this view is a
 standard screen-based display environment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#TRANSPARENCY_SORT_GEOMETRY">TRANSPARENCY_SORT_GEOMETRY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy that specifies that transparent objects
 are sorted from back to front on a per-geometry basis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#TRANSPARENCY_SORT_NONE">TRANSPARENCY_SORT_NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy that specifies that no sorting of transparent objects
 is done.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#VIRTUAL_EYE">VIRTUAL_EYE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that the associated distance is measured
 from the eye in virtual world coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#VIRTUAL_SCREEN">VIRTUAL_SCREEN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies that the associated distance is measured
 from the screen in virtual world coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#VIRTUAL_WORLD">VIRTUAL_WORLD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy for resizing and moving windows.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#VISIBILITY_DRAW_ALL">VISIBILITY_DRAW_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy that specifies that both visible and invisible objects
 should be drawn.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#VISIBILITY_DRAW_INVISIBLE">VISIBILITY_DRAW_INVISIBLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy that specifies that only invisible objects should be drawn.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#VISIBILITY_DRAW_VISIBLE">VISIBILITY_DRAW_VISIBLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Policy that specifies that only visible objects should be drawn.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#View()">View</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a View object with default parameters.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#addCanvas3D(javax.media.j3d.Canvas3D)">addCanvas3D</A></B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds the given Canvas3D at the end of the list.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#attachViewPlatform(javax.media.j3d.ViewPlatform)">attachViewPlatform</A></B>(<A HREF="../../../javax/media/j3d/ViewPlatform.html" title="class in javax.media.j3d">ViewPlatform</A>&nbsp;vp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attach viewPlatform structure to this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Enumeration</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getAllCanvas3Ds()">getAllCanvas3Ds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the enumeration object of all the Canvas3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getBackClipDistance()">getBackClipDistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the view model's back clip distance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getBackClipPolicy()">getBackClipPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the view model's current back clip policy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getCanvas3D(int)">getCanvas3D</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the Canvas3D at the specified index position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getCoexistenceCenteringEnable()">getCoexistenceCenteringEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the coexistenceCentering enable flag.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getCompatibilityModeEnable()">getCompatibilityModeEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the compatibility mode enable flag.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getCurrentFrameStartTime()">getCurrentFrameStartTime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns the time at which the most recent rendering
 frame started.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getDepthBufferFreezeTransparent()">getDepthBufferFreezeTransparent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current value of the depth buffer freeze transparent
 flag for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getFieldOfView()">getFieldOfView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current field of view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getFrameNumber()">getFrameNumber</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns the frame number for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getFrameStartTimes(long[])">getFrameStartTimes</A></B>(long[]&nbsp;times)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the last <i>k</i> frame start time values into
 the user-specified array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getFrontClipDistance()">getFrontClipDistance</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the view model's front clip distance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getFrontClipPolicy()">getFrontClipPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the view model's current front clip policy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getLastFrameDuration()">getLastFrameDuration</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This method returns the duration, in milliseconds, of the most
 recently completed rendering frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getLeftManualEyeInCoexistence(javax.vecmath.Point3d)">getLeftManualEyeInCoexistence</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the position of the user-specified, manual left eye
 in coexistence
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getLeftProjection(javax.media.j3d.Transform3D)">getLeftProjection</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;projection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compatibility mode method that retrieves the current
 compatibility mode projection transform for the left eye and
 places it into the specified object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getLocalEyeLightingEnable()">getLocalEyeLightingEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a flag that indicates whether or not local eye lighting
 is enabled for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getMaxFrameStartTimes()">getMaxFrameStartTimes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the implementation-dependent maximum number of
 frames whose start times will be recorded by the system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getMinimumFrameCycleTime()">getMinimumFrameCycleTime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the minimum frame cycle time, in milliseconds, for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getMonoscopicViewPolicy()">getMonoscopicViewPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of Java 3D version 1.2, replaced by
 <code>Canvas3D.getMonoscopicViewPolicy</code></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/PhysicalBody.html" title="class in javax.media.j3d">PhysicalBody</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getPhysicalBody()">getPhysicalBody</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to the view model's PhysicalBody object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/PhysicalEnvironment.html" title="class in javax.media.j3d">PhysicalEnvironment</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getPhysicalEnvironment()">getPhysicalEnvironment</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to the view model's PhysicalEnvironment object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getProjectionPolicy()">getProjectionPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current projection policy for this View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getRightManualEyeInCoexistence(javax.vecmath.Point3d)">getRightManualEyeInCoexistence</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the position of the user-specified, manual right eye
 in coexistence
 coordinates and copies that value into the object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getRightProjection(javax.media.j3d.Transform3D)">getRightProjection</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;projection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compatibility mode method that retrieves the current
 compatibility mode projection transform for the right eye and
 places it into the specified object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getSceneAntialiasingEnable()">getSceneAntialiasingEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a flag that indicates whether or not scene antialiasing
 is enabled for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getScreenScale()">getScreenScale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current screen scale value</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getScreenScalePolicy()">getScreenScalePolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current screen scale policy, one of:
 SCALE_SCREEN_SIZE or SCALE_EXPLICIT.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getSensorHotspotInVworld(javax.media.j3d.Sensor, javax.vecmath.Point3d)">getSensorHotspotInVworld</A></B>(<A HREF="../../../javax/media/j3d/Sensor.html" title="class in javax.media.j3d">Sensor</A>&nbsp;sensor,
                         <A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the position of the specified Sensor's 
 hotspot in virtual-world coordinates
 and copies that value into the position provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getSensorHotspotInVworld(javax.media.j3d.Sensor, javax.vecmath.Point3f)">getSensorHotspotInVworld</A></B>(<A HREF="../../../javax/media/j3d/Sensor.html" title="class in javax.media.j3d">Sensor</A>&nbsp;sensor,
                         <A HREF="../../../javax/vecmath/Point3f.html" title="class in javax.vecmath">Point3f</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the position of the specified Sensor's 
 hotspot in virtual-world coordinates
 and copies that value into the position provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getSensorToVworld(javax.media.j3d.Sensor, javax.media.j3d.Transform3D)">getSensorToVworld</A></B>(<A HREF="../../../javax/media/j3d/Sensor.html" title="class in javax.media.j3d">Sensor</A>&nbsp;sensor,
                  <A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the sensor to virtual-world transform
 and copies that value into the transform provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getTrackingEnable()">getTrackingEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a status flag indicating whether or not head tracking
 is enabled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getTransparencySortingPolicy()">getTransparencySortingPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current transparency sorting policy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getUserHeadToVworld(javax.media.j3d.Transform3D)">getUserHeadToVworld</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the user-head to virtual-world transform
 and copies that value into the transform provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getUserHeadToVworldEnable()">getUserHeadToVworldEnable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a status flag indicating whether or not
 Java 3D is continuously updating the userHeadToVworldEnable transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/j3d/ViewPlatform.html" title="class in javax.media.j3d">ViewPlatform</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getViewPlatform()">getViewPlatform</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the currently attached ViewPlatform object</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getViewPolicy()">getViewPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current view computation policy for this View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getVisibilityPolicy()">getVisibilityPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current visibility policy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getVpcToEc(javax.media.j3d.Transform3D)">getVpcToEc</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vpcToEc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compatibility mode method that retrieves the current
 ViewPlatform Coordinates (VPC) system to
 Eye Coordinates (EC) transform and copies it into the specified
 object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getWindowEyepointPolicy()">getWindowEyepointPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current window eyepoint policy, one of:
 RELATIVE_TO_SCREEN, RELATIVE_TO_WINDOW, RELATIVE_TO_FIELD_OF_VIEW or
 RELATIVE_TO_COEXISTENCE.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getWindowMovementPolicy()">getWindowMovementPolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current window movement policy,
 one of: VIRTUAL_WORLD or PHYSICAL_WORLD.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#getWindowResizePolicy()">getWindowResizePolicy</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current window resize policy, one of:
 VIRTUAL_WORLD or PHYSICAL_WORLD.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#indexOfCanvas3D(javax.media.j3d.Canvas3D)">indexOfCanvas3D</A></B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the index of the specified Canvas3D in
 this View's list of Canvas3Ds</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#insertCanvas3D(javax.media.j3d.Canvas3D, int)">insertCanvas3D</A></B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D,
               int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts the Canvas3D at the given index position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#isBehaviorSchedulerRunning()">isBehaviorSchedulerRunning</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a flag that indicates whether the behavior scheduler is
 currently running.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#isViewRunning()">isViewRunning</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a flag that indicates whether the traverser is
 currently running on this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#numCanvas3Ds()">numCanvas3Ds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of Canvas3Ds in this View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#removeAllCanvas3Ds()">removeAllCanvas3Ds</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes all Canvas3Ds from this View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#removeCanvas3D(javax.media.j3d.Canvas3D)">removeCanvas3D</A></B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the specified Canvas3D from this View's
 list of Canvas3Ds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#removeCanvas3D(int)">removeCanvas3D</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the Canvas3D from the given index position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#renderOnce()">renderOnce</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders one frame for a stopped View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#repaint()">repaint</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Requests that this View be scheduled for rendering as soon as
 possible.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setBackClipDistance(double)">setBackClipDistance</A></B>(double&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the view model's back clip distance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setBackClipPolicy(int)">setBackClipPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the view model's back clip policy, the policy Java 3D uses
 in computing where to place the back clip plane.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setCanvas3D(javax.media.j3d.Canvas3D, int)">setCanvas3D</A></B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D,
            int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets given Canvas3D at the given index position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setCoexistenceCenteringEnable(boolean)">setCoexistenceCenteringEnable</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the coexistenceCentering enable flag to true or false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setCompatibilityModeEnable(boolean)">setCompatibilityModeEnable</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the compatibility mode enable flag to true or false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setDepthBufferFreezeTransparent(boolean)">setDepthBufferFreezeTransparent</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables automatic freezing of the depth buffer for
 objects rendered
 during the transparent rendering pass (i.e., objects rendered
 using alpha blending) for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setFieldOfView(double)">setFieldOfView</A></B>(double&nbsp;fieldOfView)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the field of view used to compute the projection transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setFrontClipDistance(double)">setFrontClipDistance</A></B>(double&nbsp;distance)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the view model's front clip distance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setFrontClipPolicy(int)">setFrontClipPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the view model's front clip policy, the policy Java 3D uses
 in computing where to place the front clip plane.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setLeftManualEyeInCoexistence(javax.vecmath.Point3d)">setLeftManualEyeInCoexistence</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the position of the manual left eye in coexistence
 coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setLeftProjection(javax.media.j3d.Transform3D)">setLeftProjection</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;projection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compatibility mode method that specifies a viewing frustum for
 the left eye that transforms points in Eye Coordinates (EC) to
 Clipping Coordinates (CC).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setLocalEyeLightingEnable(boolean)">setLocalEyeLightingEnable</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a flag that indicates whether the local eyepoint is used in
 lighting calculations for perspective projections.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setMinimumFrameCycleTime(long)">setMinimumFrameCycleTime</A></B>(long&nbsp;minimumTime)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minimum frame cycle time, in milliseconds, for this
 view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setMonoscopicViewPolicy(int)">setMonoscopicViewPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>As of Java 3D version 1.2, replaced by
 <code>Canvas3D.setMonoscopicViewPolicy</code></I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setPhysicalBody(javax.media.j3d.PhysicalBody)">setPhysicalBody</A></B>(<A HREF="../../../javax/media/j3d/PhysicalBody.html" title="class in javax.media.j3d">PhysicalBody</A>&nbsp;physicalBody)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the view model's physical body to the PhysicalBody object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setPhysicalEnvironment(javax.media.j3d.PhysicalEnvironment)">setPhysicalEnvironment</A></B>(<A HREF="../../../javax/media/j3d/PhysicalEnvironment.html" title="class in javax.media.j3d">PhysicalEnvironment</A>&nbsp;physicalEnvironment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the view model's physical environment to the PhysicalEnvironment
 object provided.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setProjectionPolicy(int)">setProjectionPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the projection policy for this View.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setRightManualEyeInCoexistence(javax.vecmath.Point3d)">setRightManualEyeInCoexistence</A></B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the position of the manual right eye in coexistence
 coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setRightProjection(javax.media.j3d.Transform3D)">setRightProjection</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;projection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compatibility mode method that specifies a viewing frustum for
 the right eye that transforms points in Eye Coordinates (EC) to
 Clipping Coordinates (CC).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setSceneAntialiasingEnable(boolean)">setSceneAntialiasingEnable</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables or disables scene antialiasing for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setScreenScale(double)">setScreenScale</A></B>(double&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the screen scale value for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setScreenScalePolicy(int)">setScreenScalePolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the screen scale policy for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setTrackingEnable(boolean)">setTrackingEnable</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns head tracking on or off for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setTransparencySortingPolicy(int)">setTransparencySortingPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the transparency sorting policy for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setUserHeadToVworldEnable(boolean)">setUserHeadToVworldEnable</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns on or off the continuous
 updating of the userHeadToVworld transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setViewPolicy(int)">setViewPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the policy for view computation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setVisibilityPolicy(int)">setVisibilityPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the visibility policy for this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setVpcToEc(javax.media.j3d.Transform3D)">setVpcToEc</A></B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vpcToEc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compatibility mode method that specifies the ViewPlatform
 Coordinates (VPC) to Eye Coordinates (EC) transform.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setWindowEyepointPolicy(int)">setWindowEyepointPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the view model's window eyepoint policy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setWindowMovementPolicy(int)">setWindowMovementPolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the window movement policy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#setWindowResizePolicy(int)">setWindowResizePolicy</A></B>(int&nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the window resize policy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#startBehaviorScheduler()">startBehaviorScheduler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts the behavior scheduler running after it has been stopped.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#startView()">startView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts
 traversing this view, and starts the renderers associated
 with all canvases attached to this view.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#stopBehaviorScheduler()">stopBehaviorScheduler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stops the behavior scheduler after all
 currently scheduled behaviors are executed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/j3d/View.html#stopView()">stopView</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stops traversing the scene graph for this
 view after the current state of the scene graph is reflected on
 all canvases attached to this view.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="NOMINAL_HEAD"><!-- --></A><H3>
NOMINAL_HEAD</H3>
<PRE>
public static final int <B>NOMINAL_HEAD</B></PRE>
<DL>
<DD>Specifies a policy whereby the origin of physical or virtual
 coordinates is relative to the position of the nominal head.
 When used as a view attach policy, this sets the origin of view
 platform coordinates to be at the eyepoint.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/ViewPlatform.html#setViewAttachPolicy(int)"><CODE>ViewPlatform.setViewAttachPolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/PhysicalEnvironment.html#setCoexistenceCenterInPworldPolicy(int)"><CODE>PhysicalEnvironment.setCoexistenceCenterInPworldPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.NOMINAL_HEAD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NOMINAL_FEET"><!-- --></A><H3>
NOMINAL_FEET</H3>
<PRE>
public static final int <B>NOMINAL_FEET</B></PRE>
<DL>
<DD>Specifies a policy whereby the origin of physical or virtual
 coordinates is relative to the position of the nominal feet.
 When used as a view attach policy, this sets the origin of view
 platform coordinates to be at the ground plane.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/ViewPlatform.html#setViewAttachPolicy(int)"><CODE>ViewPlatform.setViewAttachPolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/PhysicalEnvironment.html#setCoexistenceCenterInPworldPolicy(int)"><CODE>PhysicalEnvironment.setCoexistenceCenterInPworldPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.NOMINAL_FEET">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NOMINAL_SCREEN"><!-- --></A><H3>
NOMINAL_SCREEN</H3>
<PRE>
public static final int <B>NOMINAL_SCREEN</B></PRE>
<DL>
<DD>Specifies a policy whereby the origin of physical or virtual
 coordinates is relative to the screen.
 When used as a view attach policy, this sets the origin of view
 platform coordinates to be at the center of the window or screen,
 in effect, allowing the user to view objects from an optimal viewpoint.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/ViewPlatform.html#setViewAttachPolicy(int)"><CODE>ViewPlatform.setViewAttachPolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/PhysicalEnvironment.html#setCoexistenceCenterInPworldPolicy(int)"><CODE>PhysicalEnvironment.setCoexistenceCenterInPworldPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.NOMINAL_SCREEN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SCALE_SCREEN_SIZE"><!-- --></A><H3>
SCALE_SCREEN_SIZE</H3>
<PRE>
public static final int <B>SCALE_SCREEN_SIZE</B></PRE>
<DL>
<DD>Specifies that the screen scale for this view is derived from
 the physical screen size.  This scale factor is computed as follows:
 <ul>
 physical_screen_width / 2.0
 </ul>
 This allows an application to define a world in a normalized
 [-1,1] space and view it on a screen of any size.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setScreenScalePolicy(int)"><CODE>setScreenScalePolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.SCALE_SCREEN_SIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SCALE_EXPLICIT"><!-- --></A><H3>
SCALE_EXPLICIT</H3>
<PRE>
public static final int <B>SCALE_EXPLICIT</B></PRE>
<DL>
<DD>Specifies that the screen scale for this view is taken directly
 from the user-provided screenScale parameter.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setScreenScalePolicy(int)"><CODE>setScreenScalePolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/View.html#setScreenScale(double)"><CODE>setScreenScale(double)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.SCALE_EXPLICIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VIRTUAL_SCREEN"><!-- --></A><H3>
VIRTUAL_SCREEN</H3>
<PRE>
public static final int <B>VIRTUAL_SCREEN</B></PRE>
<DL>
<DD>Specifies that the associated distance is measured
 from the screen in virtual world coordinates.
 Policy for interpreting clip plane distances.
 Used in specifying the policy in frontClipPolicy and backClipPolicy.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setFrontClipPolicy(int)"><CODE>setFrontClipPolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/View.html#setBackClipPolicy(int)"><CODE>setBackClipPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.VIRTUAL_SCREEN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PHYSICAL_SCREEN"><!-- --></A><H3>
PHYSICAL_SCREEN</H3>
<PRE>
public static final int <B>PHYSICAL_SCREEN</B></PRE>
<DL>
<DD>Specifies that the associated distance is measured
 from the screen in meters.
 Policy for interpreting clip plane distances.
 Used in specifying the policy in frontClipPolicy and backClipPolicy.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setFrontClipPolicy(int)"><CODE>setFrontClipPolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/View.html#setBackClipPolicy(int)"><CODE>setBackClipPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.PHYSICAL_SCREEN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VIRTUAL_EYE"><!-- --></A><H3>
VIRTUAL_EYE</H3>
<PRE>
public static final int <B>VIRTUAL_EYE</B></PRE>
<DL>
<DD>Specifies that the associated distance is measured
 from the eye in virtual world coordinates.
 Policy for interpreting clip plane distances.
 Used in specifying the policy in frontClipPolicy and backClipPolicy.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setFrontClipPolicy(int)"><CODE>setFrontClipPolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/View.html#setBackClipPolicy(int)"><CODE>setBackClipPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.VIRTUAL_EYE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PHYSICAL_EYE"><!-- --></A><H3>
PHYSICAL_EYE</H3>
<PRE>
public static final int <B>PHYSICAL_EYE</B></PRE>
<DL>
<DD>Specifies that the associated distance is measured
 from the eye in meters.
 Policy for interpreting clip plane distances.
 Used in specifying the policy in frontClipPolicy and backClipPolicy.
 This is the default policy for both front and back clipping.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setFrontClipPolicy(int)"><CODE>setFrontClipPolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/View.html#setBackClipPolicy(int)"><CODE>setBackClipPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.PHYSICAL_EYE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VIRTUAL_WORLD"><!-- --></A><H3>
VIRTUAL_WORLD</H3>
<PRE>
public static final int <B>VIRTUAL_WORLD</B></PRE>
<DL>
<DD>Policy for resizing and moving windows.
 Used in specifying windowResizePolicy and windowMovementPolicy.
 VIRTUAL_WORLD specifies that the associated action takes place
 in the virtual world as well as in the physical world.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setWindowResizePolicy(int)"><CODE>setWindowResizePolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/View.html#setWindowMovementPolicy(int)"><CODE>setWindowMovementPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.VIRTUAL_WORLD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PHYSICAL_WORLD"><!-- --></A><H3>
PHYSICAL_WORLD</H3>
<PRE>
public static final int <B>PHYSICAL_WORLD</B></PRE>
<DL>
<DD>Policy for resizing and moving windows.
 Used in specifying windowResizePolicy and windowMovementPolicy.
 PHYSICAL_WORLD specifies that the specified action takes place
 only in the physical world.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setWindowResizePolicy(int)"><CODE>setWindowResizePolicy(int)</CODE></A>, 
<A HREF="../../../javax/media/j3d/View.html#setWindowMovementPolicy(int)"><CODE>setWindowMovementPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.PHYSICAL_WORLD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RELATIVE_TO_SCREEN"><!-- --></A><H3>
RELATIVE_TO_SCREEN</H3>
<PRE>
public static final int <B>RELATIVE_TO_SCREEN</B></PRE>
<DL>
<DD>Policy for placing the eyepoint in non-head-tracked modes.
 Specifies that Java 3D should interpret the
 given fixed eyepoint position as relative to the entire screen.
 This implies
 that the view frustum shape will change whenever a
 user moves the location of a window on the screen.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setWindowEyepointPolicy(int)"><CODE>setWindowEyepointPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.RELATIVE_TO_SCREEN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RELATIVE_TO_WINDOW"><!-- --></A><H3>
RELATIVE_TO_WINDOW</H3>
<PRE>
public static final int <B>RELATIVE_TO_WINDOW</B></PRE>
<DL>
<DD>Policy for placing the eyepoint in non-head-tracked modes.
 Specifies that Java 3D should interpret the
 given fixed-eyepoint position as relative to the window.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setWindowEyepointPolicy(int)"><CODE>setWindowEyepointPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.RELATIVE_TO_WINDOW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RELATIVE_TO_FIELD_OF_VIEW"><!-- --></A><H3>
RELATIVE_TO_FIELD_OF_VIEW</H3>
<PRE>
public static final int <B>RELATIVE_TO_FIELD_OF_VIEW</B></PRE>
<DL>
<DD>Policy for placing the eyepoint in non-head-tracked modes.
 Specifies that Java 3D should
 modify the position of the eyepoint to match any changes in field
 of view; the view frustum will change whenever the application
 program changes the field of view.
 <p>
 NOTE: when this policy is specified, the Z coordinate of
 the derived eyepoint is used in place of
 nominalEyeOffsetFromNominalScreen.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setWindowEyepointPolicy(int)"><CODE>setWindowEyepointPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.RELATIVE_TO_FIELD_OF_VIEW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RELATIVE_TO_COEXISTENCE"><!-- --></A><H3>
RELATIVE_TO_COEXISTENCE</H3>
<PRE>
public static final int <B>RELATIVE_TO_COEXISTENCE</B></PRE>
<DL>
<DD>Policy for placing the eyepoint in non-head-tracked modes.
 Specifies that Java 3D should interpret the fixed eyepoint
 position in the view as relative to the origin
 of coexistence coordinates.  This eyepoint is transformed from
 coexistence coordinates to image plate coordinates for each
 Canvas3D.
 As in RELATIVE_TO_SCREEN mode, this implies
 that the view frustum shape will change whenever a
 user moves the location of a window on the screen.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setWindowEyepointPolicy(int)"><CODE>setWindowEyepointPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.RELATIVE_TO_COEXISTENCE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LEFT_EYE_VIEW"><!-- --></A><H3>
LEFT_EYE_VIEW</H3>
<PRE>
public static final int <B>LEFT_EYE_VIEW</B></PRE>
<DL>
<DD>Specifies that monoscopic view generated should be the view as seen
 from the left eye.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#setMonoscopicViewPolicy(int)"><CODE>Canvas3D.setMonoscopicViewPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.LEFT_EYE_VIEW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RIGHT_EYE_VIEW"><!-- --></A><H3>
RIGHT_EYE_VIEW</H3>
<PRE>
public static final int <B>RIGHT_EYE_VIEW</B></PRE>
<DL>
<DD>Specifies that monoscopic view generated should be the view as seen
 from the right eye.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#setMonoscopicViewPolicy(int)"><CODE>Canvas3D.setMonoscopicViewPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.RIGHT_EYE_VIEW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="CYCLOPEAN_EYE_VIEW"><!-- --></A><H3>
CYCLOPEAN_EYE_VIEW</H3>
<PRE>
public static final int <B>CYCLOPEAN_EYE_VIEW</B></PRE>
<DL>
<DD>Specifies that monoscopic view generated should be the view as seen
 from the 'center eye', the fictional eye half-way between the left and
 right eye.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#setMonoscopicViewPolicy(int)"><CODE>Canvas3D.setMonoscopicViewPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.CYCLOPEAN_EYE_VIEW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SCREEN_VIEW"><!-- --></A><H3>
SCREEN_VIEW</H3>
<PRE>
public static final int <B>SCREEN_VIEW</B></PRE>
<DL>
<DD>Specifies that the viewing environment for this view is a
 standard screen-based display environment.
 In this mode, Java 3D will compute new viewpoints
 using that sequence of transforms appropriate to screen-based,
 display environments, that may or may not include head tracking
 (e.g., a monoscopic screen, fish-tank VR, portals, VR-desks).
 This is the default mode.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setViewPolicy(int)"><CODE>setViewPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.SCREEN_VIEW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="HMD_VIEW"><!-- --></A><H3>
HMD_VIEW</H3>
<PRE>
public static final int <B>HMD_VIEW</B></PRE>
<DL>
<DD>Specifies that the viewing environment for this view is a
 head-mounted display environment.
 In this mode, Java 3D will compute new viewpoints
 using that sequence of transforms appropriate to head-mounted display
 environments.  These environments are generally head-tracked.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setViewPolicy(int)"><CODE>setViewPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.HMD_VIEW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PARALLEL_PROJECTION"><!-- --></A><H3>
PARALLEL_PROJECTION</H3>
<PRE>
public static final int <B>PARALLEL_PROJECTION</B></PRE>
<DL>
<DD>Specifies that Java 3D should generate a parallel projection matrix
 for this View.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setProjectionPolicy(int)"><CODE>setProjectionPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.PARALLEL_PROJECTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PERSPECTIVE_PROJECTION"><!-- --></A><H3>
PERSPECTIVE_PROJECTION</H3>
<PRE>
public static final int <B>PERSPECTIVE_PROJECTION</B></PRE>
<DL>
<DD>Specifies that Java 3D should generate a perspective projection matrix
 for this View.
 This is the default mode.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setProjectionPolicy(int)"><CODE>setProjectionPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.PERSPECTIVE_PROJECTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VISIBILITY_DRAW_VISIBLE"><!-- --></A><H3>
VISIBILITY_DRAW_VISIBLE</H3>
<PRE>
public static final int <B>VISIBILITY_DRAW_VISIBLE</B></PRE>
<DL>
<DD>Policy that specifies that only visible objects should be drawn.
 This is the default mode.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setVisibilityPolicy(int)"><CODE>setVisibilityPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.VISIBILITY_DRAW_VISIBLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VISIBILITY_DRAW_INVISIBLE"><!-- --></A><H3>
VISIBILITY_DRAW_INVISIBLE</H3>
<PRE>
public static final int <B>VISIBILITY_DRAW_INVISIBLE</B></PRE>
<DL>
<DD>Policy that specifies that only invisible objects should be drawn.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setVisibilityPolicy(int)"><CODE>setVisibilityPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.VISIBILITY_DRAW_INVISIBLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VISIBILITY_DRAW_ALL"><!-- --></A><H3>
VISIBILITY_DRAW_ALL</H3>
<PRE>
public static final int <B>VISIBILITY_DRAW_ALL</B></PRE>
<DL>
<DD>Policy that specifies that both visible and invisible objects
 should be drawn.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setVisibilityPolicy(int)"><CODE>setVisibilityPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.VISIBILITY_DRAW_ALL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSPARENCY_SORT_NONE"><!-- --></A><H3>
TRANSPARENCY_SORT_NONE</H3>
<PRE>
public static final int <B>TRANSPARENCY_SORT_NONE</B></PRE>
<DL>
<DD>Policy that specifies that no sorting of transparent objects
 is done.
 This is the default mode.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setTransparencySortingPolicy(int)"><CODE>setTransparencySortingPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.TRANSPARENCY_SORT_NONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRANSPARENCY_SORT_GEOMETRY"><!-- --></A><H3>
TRANSPARENCY_SORT_GEOMETRY</H3>
<PRE>
public static final int <B>TRANSPARENCY_SORT_GEOMETRY</B></PRE>
<DL>
<DD>Policy that specifies that transparent objects
 are sorted from back to front on a per-geometry basis.
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setTransparencySortingPolicy(int)"><CODE>setTransparencySortingPolicy(int)</CODE></A>, 
<A HREF="../../../constant-values.html#javax.media.j3d.View.TRANSPARENCY_SORT_GEOMETRY">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="View()"><!-- --></A><H3>
View</H3>
<PRE>
public <B>View</B>()</PRE>
<DL>
<DD>Constructs a View object with default parameters.  The default
 values are as follows:
 <ul>
 view policy : SCREEN_VIEW<br>
 projection policy : PERSPECTIVE_PROJECTION<br>
 screen scale policy : SCALE_SCREEN_SIZE<br>
 window resize policy : PHYSICAL_WORLD<br>
 window movement policy : PHYSICAL_WORLD<br>
 window eyepoint policy : RELATIVE_TO_FIELD_OF_VIEW<br>
 monoscopic view policy : CYCLOPEAN_EYE_VIEW<br>
 front clip policy : PHYSICAL_EYE<br>
 back clip policy : PHYSICAL_EYE<br>
 visibility policy : VISIBILITY_DRAW_VISIBLE<br>
 transparency sorting policy : TRANSPARENCY_SORT_NONE<br>
 coexistenceCentering flag : true<br>
 compatibility mode : false<br>
 left projection : identity<br>
 right projection : identity<br>
 vpc to ec transform : identity<br>
 physical body : null<br>
 physical environment : null<br>
 screen scale : 1.0<br>
 field of view : PI/4<br>
 left manual eye in coexistence : (-0.033, 0.0, 0.4572)<br>
 right manual eye in coexistence : (0.033, 0.0, 0.4572)<br>
 front clip distance : 0.1<br>
 back clip distance : 10.0<br>
 tracking enable : false<br>
 user head to vworld enable : false<br>
 list of Canvas3D objects : empty<br>
 depth buffer freeze transparent : true<br>
 scene antialiasing : false<br>
 local eye lighting : false<br>
 view platform : null<br>
 behavior scheduler running : true<br>
 view running : true<br>
 minimum frame cycle time : 0<br>
 </ul>
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setViewPolicy(int)"><!-- --></A><H3>
setViewPolicy</H3>
<PRE>
public void <B>setViewPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the policy for view computation.
 This variable specifies how Java 3D uses its transforms in
 computing new viewpoints.
 <UL>
 <LI>SCREEN_VIEW specifies that Java 3D should compute a new viewpoint
 using the sequence of transforms appropriate to screen-based
 head-tracked display environments (fish-tank VR/portals/VR-desks).
 </LI>
 <LI>HMD_VIEW specifies that Java 3D should compute a new viewpoint
 using the sequence of transforms appropriate to head mounted
 display environments.
 </LI>
 </UL>
 The default view policy is SCREEN_VIEW.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of SCREEN_VIEW or HMD_VIEW
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if policy is a value other than
 SCREEN_VIEW or HMD_VIEW
<DD><CODE>java.lang.IllegalStateException</CODE> - if the specified policy
 is HMD_VIEW and if any canvas associated with this view is
 a stereo canvas with a monoscopicEyePolicy of CYCLOPEAN_EYE_VIEW</DL>
</DD>
</DL>
<HR>

<A NAME="getViewPolicy()"><!-- --></A><H3>
getViewPolicy</H3>
<PRE>
public int <B>getViewPolicy</B>()</PRE>
<DL>
<DD>Retrieves the current view computation policy for this View.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>one of: SCREEN_VIEW or HMD_VIEW.</DL>
</DD>
</DL>
<HR>

<A NAME="setProjectionPolicy(int)"><!-- --></A><H3>
setProjectionPolicy</H3>
<PRE>
public void <B>setProjectionPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the projection policy for this View.
 This variable specifies the type of projection transform that
 will be generated.  A value of PARALLEL_PROJECTION specifies that
 a parallel projection transform is generated.  A value of
 PERSPECTIVE_PROJECTION specifies that
 a perspective projection transform is generated.
 The default projection policy is PERSPECTIVE.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of PARALLEL_PROJECTION or
 PERSPECTIVE_PROJECTION
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if policy is a value other than
 PARALLEL_PROJECTION or PERSPECTIVE_PROJECTION</DL>
</DD>
</DL>
<HR>

<A NAME="getProjectionPolicy()"><!-- --></A><H3>
getProjectionPolicy</H3>
<PRE>
public int <B>getProjectionPolicy</B>()</PRE>
<DL>
<DD>Retrieves the current projection policy for this View.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>one of: PARALLEL_PROJECTION or PERSPECTIVE_PROJECTION.</DL>
</DD>
</DL>
<HR>

<A NAME="setScreenScalePolicy(int)"><!-- --></A><H3>
setScreenScalePolicy</H3>
<PRE>
public void <B>setScreenScalePolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the screen scale policy for this view.
 This policy specifies how the screen scale is derived.
 The value is either SCALE_SCREEN_SIZE or SCALE_EXPLICIT.
 A value of SCALE_SCREEN_SIZE specifies that the scale is derived
 from the size of the physical screen.  A value of SCALE_EXPLICIT
 specifies that the scale is taken directly from the screenScale
 parameter.
 The default screen scale policy is SCALE_SCREEN_SIZE.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of SCALE_SCREEN_SIZE or
 SCALE_EXPLICIT.</DL>
</DD>
</DL>
<HR>

<A NAME="getScreenScalePolicy()"><!-- --></A><H3>
getScreenScalePolicy</H3>
<PRE>
public int <B>getScreenScalePolicy</B>()</PRE>
<DL>
<DD>Returns the current screen scale policy, one of:
 SCALE_SCREEN_SIZE or SCALE_EXPLICIT.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current screen scale policy</DL>
</DD>
</DL>
<HR>

<A NAME="setWindowResizePolicy(int)"><!-- --></A><H3>
setWindowResizePolicy</H3>
<PRE>
public void <B>setWindowResizePolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the window resize policy.
 This variable specifies how Java 3D modifies the view when
 users resize windows. The variable can contain one of
 VIRTUAL_WORLD or PHYSICAL_WORLD.
 A value of VIRTUAL_WORLD implies that the original image
 remains the same size on the screen but the user sees more
 or less of the virtual world depending on whether the window
 grew or shrank in size.
 A value of PHYSICAL_WORLD implies that the original image
 continues to fill the window in the same way using more or
 less pixels depending on whether the window grew or shrank
 in size.
 The default window resize policy is PHYSICAL_WORLD.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of VIRTUAL_WORLD or PHYSICAL_WORLD</DL>
</DD>
</DL>
<HR>

<A NAME="getWindowResizePolicy()"><!-- --></A><H3>
getWindowResizePolicy</H3>
<PRE>
public int <B>getWindowResizePolicy</B>()</PRE>
<DL>
<DD>Returns the current window resize policy, one of:
 VIRTUAL_WORLD or PHYSICAL_WORLD.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current window resize policy</DL>
</DD>
</DL>
<HR>

<A NAME="setWindowMovementPolicy(int)"><!-- --></A><H3>
setWindowMovementPolicy</H3>
<PRE>
public void <B>setWindowMovementPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the window movement policy.
 This variable specifies what part of the virtual world Java 3D
 draws as a function of window placement on the screen. The
 variable can contain one of VIRTUAL_WORLD or PHYSICAL_WORLD.
 A value of VIRTUAL_WORLD implies that the image seen in the
 window changes as the position of the window shifts on the
 screen.  (This mode acts as if the window were a window into
 the virtual world.)
 A value of PHYSICAL_WORLD implies that the image seen in the
 window remains the same no matter where the user positions
 the window on the screen.
 The default window movement policy is PHYSICAL_WORLD.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of VIRTUAL_WORLD or PHYSICAL_WORLD</DL>
</DD>
</DL>
<HR>

<A NAME="getWindowMovementPolicy()"><!-- --></A><H3>
getWindowMovementPolicy</H3>
<PRE>
public int <B>getWindowMovementPolicy</B>()</PRE>
<DL>
<DD>Returns the current window movement policy,
 one of: VIRTUAL_WORLD or PHYSICAL_WORLD.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current window movement policy</DL>
</DD>
</DL>
<HR>

<A NAME="setWindowEyepointPolicy(int)"><!-- --></A><H3>
setWindowEyepointPolicy</H3>
<PRE>
public void <B>setWindowEyepointPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the view model's window eyepoint policy.
 This variable specifies how Java 3D handles the predefined eye
 point in a non-head-tracked environment.  The variable can contain
 one of:
 <UL>
 <LI>RELATIVE_TO_SCREEN, Java 3D should interpret the
 given fixed-eyepoint position as relative to the screen (this
 implies that the view frustum shape will change whenever a
 user moves the location of a window on the screen).
 </LI>
 <LI>RELATIVE_TO_WINDOW, Java 3D should interpret the
 given fixed-eyepoint position as relative to the window.  In this
 mode, the X and Y values are taken as the center of the window and
 the Z value is taken from the canvas eyepoint position.
 </LI>
 <LI>RELATIVE_TO_FIELD_OF_VIEW, Java 3D should
 modify the position of the eyepoint to match any changes in field
 of view (the view frustum will change whenever the application
 program changes the field of view).
 </LI>
 <LI>RELATIVE_TO_COEXISTENCE, Java 3D should interpret the eye's
 position in coexistence coordinates. In this mode, the eye position
 is taken from the view (rather than the Canvas3D) and transformed from
 coexistence coordinates to image plate coordinates for each
 Canvas3D.  The resulting eye position is relative to the screen (this
 implies that the view frustum shape will change whenever a
 user moves the location of a window on the screen).
 </LI>
 </UL>
 The default window eyepoint policy is RELATIVE_TO_FIELD_OF_VIEW.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of RELATIVE_TO_SCREEN,
 RELATIVE_TO_WINDOW, RELATIVE_TO_FIELD_OF_VIEW, or
 RELATIVE_TO_COEXISTENCE</DL>
</DD>
</DL>
<HR>

<A NAME="getWindowEyepointPolicy()"><!-- --></A><H3>
getWindowEyepointPolicy</H3>
<PRE>
public int <B>getWindowEyepointPolicy</B>()</PRE>
<DL>
<DD>Returns the current window eyepoint policy, one of:
 RELATIVE_TO_SCREEN, RELATIVE_TO_WINDOW, RELATIVE_TO_FIELD_OF_VIEW or
 RELATIVE_TO_COEXISTENCE.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current window eyepoint policy</DL>
</DD>
</DL>
<HR>

<A NAME="setMonoscopicViewPolicy(int)"><!-- --></A><H3>
setMonoscopicViewPolicy</H3>
<PRE>
public void <B>setMonoscopicViewPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of Java 3D version 1.2, replaced by
 <code>Canvas3D.setMonoscopicViewPolicy</code></I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMonoscopicViewPolicy()"><!-- --></A><H3>
getMonoscopicViewPolicy</H3>
<PRE>
public int <B>getMonoscopicViewPolicy</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>As of Java 3D version 1.2, replaced by
 <code>Canvas3D.getMonoscopicViewPolicy</code></I>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCoexistenceCenteringEnable(boolean)"><!-- --></A><H3>
setCoexistenceCenteringEnable</H3>
<PRE>
public void <B>setCoexistenceCenteringEnable</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Sets the coexistenceCentering enable flag to true or false.
 If the coexistenceCentering flag is true, the center of
 coexistence in image plate coordinates, as specified by the
 trackerBaseToImagePlate transform, is translated to the center
 of either the window or the screen in image plate coordinates,
 according to the value of windowMovementPolicy.

 <p>
 By default, coexistenceCentering is enabled.  It should be
 disabled if the trackerBaseToImagePlate calibration transform
 is set to a value other than the identity (for example, when
 rendering to multiple screens or when head tracking is
 enabled).  This flag is ignored for HMD mode, or when the
 coexistenceCenterInPworldPolicy is <i>not</i>
 NOMINAL_SCREEN.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - the new coexistenceCentering enable flag<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCoexistenceCenteringEnable()"><!-- --></A><H3>
getCoexistenceCenteringEnable</H3>
<PRE>
public boolean <B>getCoexistenceCenteringEnable</B>()</PRE>
<DL>
<DD>Retrieves the coexistenceCentering enable flag.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current coexistenceCentering enable flag<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCompatibilityModeEnable(boolean)"><!-- --></A><H3>
setCompatibilityModeEnable</H3>
<PRE>
public void <B>setCompatibilityModeEnable</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Sets the compatibility mode enable flag to true or false.
 Compatibility mode is disabled by default.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - the new compatibility mode enable flag</DL>
</DD>
</DL>
<HR>

<A NAME="getCompatibilityModeEnable()"><!-- --></A><H3>
getCompatibilityModeEnable</H3>
<PRE>
public boolean <B>getCompatibilityModeEnable</B>()</PRE>
<DL>
<DD>Retrieves the compatibility mode enable flag.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current compatibility mode enable flag</DL>
</DD>
</DL>
<HR>

<A NAME="setLeftProjection(javax.media.j3d.Transform3D)"><!-- --></A><H3>
setLeftProjection</H3>
<PRE>
public void <B>setLeftProjection</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;projection)</PRE>
<DL>
<DD>Compatibility mode method that specifies a viewing frustum for
 the left eye that transforms points in Eye Coordinates (EC) to
 Clipping Coordinates (CC).
 If compatibility mode is disabled, then this transform is not used;
 the actual projection is derived from other values.
 In monoscopic mode, only the left eye projection matrix is used.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>projection</CODE> - the new left eye projection transform
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if compatibility mode is disabled.</DL>
</DD>
</DL>
<HR>

<A NAME="setRightProjection(javax.media.j3d.Transform3D)"><!-- --></A><H3>
setRightProjection</H3>
<PRE>
public void <B>setRightProjection</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;projection)</PRE>
<DL>
<DD>Compatibility mode method that specifies a viewing frustum for
 the right eye that transforms points in Eye Coordinates (EC) to
 Clipping Coordinates (CC).
 If compatibility mode is disabled, then this transform is not used;
 the actual projection is derived from other values.
 In monoscopic mode, the right eye projection matrix is ignored.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>projection</CODE> - the new right eye projection transform
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if compatibility mode is disabled.</DL>
</DD>
</DL>
<HR>

<A NAME="getLeftProjection(javax.media.j3d.Transform3D)"><!-- --></A><H3>
getLeftProjection</H3>
<PRE>
public void <B>getLeftProjection</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;projection)</PRE>
<DL>
<DD>Compatibility mode method that retrieves the current
 compatibility mode projection transform for the left eye and
 places it into the specified object.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>projection</CODE> - the Transform3D object that will receive the
 projection
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if compatibility mode is disabled.</DL>
</DD>
</DL>
<HR>

<A NAME="getRightProjection(javax.media.j3d.Transform3D)"><!-- --></A><H3>
getRightProjection</H3>
<PRE>
public void <B>getRightProjection</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;projection)</PRE>
<DL>
<DD>Compatibility mode method that retrieves the current
 compatibility mode projection transform for the right eye and
 places it into the specified object.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>projection</CODE> - the Transform3D object that will receive the
 projection
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if compatibility mode is disabled.</DL>
</DD>
</DL>
<HR>

<A NAME="setVpcToEc(javax.media.j3d.Transform3D)"><!-- --></A><H3>
setVpcToEc</H3>
<PRE>
public void <B>setVpcToEc</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vpcToEc)</PRE>
<DL>
<DD>Compatibility mode method that specifies the ViewPlatform
 Coordinates (VPC) to Eye Coordinates (EC) transform.
 If compatibility mode is disabled, then this transform
 is derived from other values and is read-only.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vpcToEc</CODE> - the new VPC to EC transform
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if compatibility mode is disabled.
<DD><CODE><A HREF="../../../javax/media/j3d/BadTransformException.html" title="class in javax.media.j3d">BadTransformException</A></CODE> - if the transform is not affine.</DL>
</DD>
</DL>
<HR>

<A NAME="getVpcToEc(javax.media.j3d.Transform3D)"><!-- --></A><H3>
getVpcToEc</H3>
<PRE>
public void <B>getVpcToEc</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;vpcToEc)</PRE>
<DL>
<DD>Compatibility mode method that retrieves the current
 ViewPlatform Coordinates (VPC) system to
 Eye Coordinates (EC) transform and copies it into the specified
 object.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vpcToEc</CODE> - the object that will receive the vpcToEc transform.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../javax/media/j3d/RestrictedAccessException.html" title="class in javax.media.j3d">RestrictedAccessException</A></CODE> - if compatibility mode is disabled.</DL>
</DD>
</DL>
<HR>

<A NAME="setPhysicalBody(javax.media.j3d.PhysicalBody)"><!-- --></A><H3>
setPhysicalBody</H3>
<PRE>
public void <B>setPhysicalBody</B>(<A HREF="../../../javax/media/j3d/PhysicalBody.html" title="class in javax.media.j3d">PhysicalBody</A>&nbsp;physicalBody)</PRE>
<DL>
<DD>Sets the view model's physical body to the PhysicalBody object provided.
 Java 3D uses the parameters in the PhysicalBody to ensure accurate
 image and sound generation when in head-tracked mode.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>physicalBody</CODE> - the new PhysicalBody object</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalBody()"><!-- --></A><H3>
getPhysicalBody</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/PhysicalBody.html" title="class in javax.media.j3d">PhysicalBody</A> <B>getPhysicalBody</B>()</PRE>
<DL>
<DD>Returns a reference to the view model's PhysicalBody object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the view object's PhysicalBody object</DL>
</DD>
</DL>
<HR>

<A NAME="setPhysicalEnvironment(javax.media.j3d.PhysicalEnvironment)"><!-- --></A><H3>
setPhysicalEnvironment</H3>
<PRE>
public void <B>setPhysicalEnvironment</B>(<A HREF="../../../javax/media/j3d/PhysicalEnvironment.html" title="class in javax.media.j3d">PhysicalEnvironment</A>&nbsp;physicalEnvironment)</PRE>
<DL>
<DD>Sets the view model's physical environment to the PhysicalEnvironment
 object provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>physicalEnvironment</CODE> - the new PhysicalEnvironment object</DL>
</DD>
</DL>
<HR>

<A NAME="getPhysicalEnvironment()"><!-- --></A><H3>
getPhysicalEnvironment</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/PhysicalEnvironment.html" title="class in javax.media.j3d">PhysicalEnvironment</A> <B>getPhysicalEnvironment</B>()</PRE>
<DL>
<DD>Returns a reference to the view model's PhysicalEnvironment object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the view object's PhysicalEnvironment object</DL>
</DD>
</DL>
<HR>

<A NAME="setScreenScale(double)"><!-- --></A><H3>
setScreenScale</H3>
<PRE>
public void <B>setScreenScale</B>(double&nbsp;scale)</PRE>
<DL>
<DD>Sets the screen scale value for this view.
 This is used when the screen scale policy is SCALE_EXPLICIT.
 The default value is 1.0 (i.e., unscaled).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scale</CODE> - the new screen scale</DL>
</DD>
</DL>
<HR>

<A NAME="getScreenScale()"><!-- --></A><H3>
getScreenScale</H3>
<PRE>
public double <B>getScreenScale</B>()</PRE>
<DL>
<DD>Returns the current screen scale value
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current screen scale value</DL>
</DD>
</DL>
<HR>

<A NAME="setFieldOfView(double)"><!-- --></A><H3>
setFieldOfView</H3>
<PRE>
public void <B>setFieldOfView</B>(double&nbsp;fieldOfView)</PRE>
<DL>
<DD>Sets the field of view used to compute the projection transform.
 This is used when head tracking is disabled and when the Canvas3D's
 windowEyepointPolicy is RELATIVE_TO_FIELD_OF_VIEW.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fieldOfView</CODE> - the new field of view in radians</DL>
</DD>
</DL>
<HR>

<A NAME="getFieldOfView()"><!-- --></A><H3>
getFieldOfView</H3>
<PRE>
public double <B>getFieldOfView</B>()</PRE>
<DL>
<DD>Returns the current field of view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current field of view in radians</DL>
</DD>
</DL>
<HR>

<A NAME="setLeftManualEyeInCoexistence(javax.vecmath.Point3d)"><!-- --></A><H3>
setLeftManualEyeInCoexistence</H3>
<PRE>
public void <B>setLeftManualEyeInCoexistence</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Sets the position of the manual left eye in coexistence
 coordinates.  This value determines eye placement when a head
 tracker is not in use and the application is directly controlling
 the eye position in coexistence coordinates.  This value is
 ignored when in head-tracked mode or when the
 windowEyePointPolicy is <i>not</i> RELATIVE_TO_COEXISTENCE.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the new manual left eye position<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRightManualEyeInCoexistence(javax.vecmath.Point3d)"><!-- --></A><H3>
setRightManualEyeInCoexistence</H3>
<PRE>
public void <B>setRightManualEyeInCoexistence</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Sets the position of the manual right eye in coexistence
 coordinates.  This value determines eye placement when a head
 tracker is not in use and the application is directly controlling
 the eye position in coexistence coordinates.  This value is
 ignored when in head-tracked mode or when the
 windowEyePointPolicy is <i>not</i> RELATIVE_TO_COEXISTENCE.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the new manual right eye position<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLeftManualEyeInCoexistence(javax.vecmath.Point3d)"><!-- --></A><H3>
getLeftManualEyeInCoexistence</H3>
<PRE>
public void <B>getLeftManualEyeInCoexistence</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the position of the user-specified, manual left eye
 in coexistence
 coordinates and copies that value into the object provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the object that will receive the position<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRightManualEyeInCoexistence(javax.vecmath.Point3d)"><!-- --></A><H3>
getRightManualEyeInCoexistence</H3>
<PRE>
public void <B>getRightManualEyeInCoexistence</B>(<A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the position of the user-specified, manual right eye
 in coexistence
 coordinates and copies that value into the object provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>position</CODE> - the object that will receive the position<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setFrontClipDistance(double)"><!-- --></A><H3>
setFrontClipDistance</H3>
<PRE>
public void <B>setFrontClipDistance</B>(double&nbsp;distance)</PRE>
<DL>
<DD>Sets the view model's front clip distance.
 This value specifies the distance away from the eyepoint
 in the direction of gaze where objects stop disappearing.
 Objects closer to the eye than the front clip
 distance are not drawn. The default value is 0.1 meters.
 <p>
 There are several considerations that need to be taken into
 account when choosing values for the front and back clip
 distances.
 <ul>
 <li>The front clip distance must be greater than
 0.0 in physical eye coordinates.</li>
 <li>The front clipping plane must be in front of the
 back clipping plane, that is, the front clip distance
 must be less than the back clip distance in physical eye
 coordinates.</li>
 <li>The front and back clip distances, in physical
 eye coordinates, must be less than the largest positive
 single-precision floating point value, <code>Float.MAX_VALUE</code>.
 In practice, since these physical eye coordinate distances are in
 meters, the values should be <i>much</i> less than that.
 <li>The ratio of the back distance divided by the front distance,
 in physical eye coordinates, affects Z-buffer precision. This
 ratio should be less than about 3000 in order to accommodate 16-bit
 Z-buffers. Values of 100 to less than 1000 will produce better
 results.</li>
 </ul>
 Violating any of the above rules will result in undefined
 behavior. In many cases, no picture will be drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>distance</CODE> - the new front clip distance<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setBackClipDistance(double)"><CODE>setBackClipDistance(double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFrontClipDistance()"><!-- --></A><H3>
getFrontClipDistance</H3>
<PRE>
public double <B>getFrontClipDistance</B>()</PRE>
<DL>
<DD>Returns the view model's front clip distance.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current front clip distance</DL>
</DD>
</DL>
<HR>

<A NAME="setBackClipDistance(double)"><!-- --></A><H3>
setBackClipDistance</H3>
<PRE>
public void <B>setBackClipDistance</B>(double&nbsp;distance)</PRE>
<DL>
<DD>Sets the view model's back clip distance.
 The parameter specifies the distance from the eyepoint
 in the direction of gaze to where objects begin disappearing.
 Objects farther away from the eye than the
 back clip distance are not drawn.
 The default value is 10.0 meters.
 <p>
 There are several considerations that need to be taken into
 account when choosing values for the front and back clip
 distances. These are enumerated in the description of
 <a href=#setFrontClipDistance(double)>setFrontClipDistance</a>.
 <p>
 Note that this attribute is only used if there is no Clip node
 that is in scope of the view platform associated with this view.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>distance</CODE> - the new back clip distance<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setFrontClipDistance(double)"><CODE>setFrontClipDistance(double)</CODE></A>, 
<A HREF="../../../javax/media/j3d/Clip.html#setBackDistance(double)"><CODE>Clip.setBackDistance(double)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBackClipDistance()"><!-- --></A><H3>
getBackClipDistance</H3>
<PRE>
public double <B>getBackClipDistance</B>()</PRE>
<DL>
<DD>Returns the view model's back clip distance.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current back clip distance</DL>
</DD>
</DL>
<HR>

<A NAME="getUserHeadToVworld(javax.media.j3d.Transform3D)"><!-- --></A><H3>
getUserHeadToVworld</H3>
<PRE>
public void <B>getUserHeadToVworld</B>(<A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;t)</PRE>
<DL>
<DD>Retrieves the user-head to virtual-world transform
 and copies that value into the transform provided.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - the Transform3D object that will receive the transform</DL>
</DD>
</DL>
<HR>

<A NAME="setFrontClipPolicy(int)"><!-- --></A><H3>
setFrontClipPolicy</H3>
<PRE>
public void <B>setFrontClipPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the view model's front clip policy, the policy Java 3D uses
 in computing where to place the front clip plane. The variable 
 can contain one of:
 <UL>
 <LI>VIRTUAL_EYE, to specify that the associated distance is
 from the eye and in units of virtual distance
 </LI>
 <LI>PHYSICAL_EYE, to specify that the associated distance is
 from the eye and in units of physical distance (meters)
 </LI>
 <LI>VIRTUAL_SCREEN, to specify that the associated distance is
 from the screen and in units of virtual distance
 </LI>
 <LI>PHYSICAL_SCREEN, to specify that the associated distance is
 from the screen and in units of physical distance (meters)
 </LI>
 </UL>
 The default front clip policy is PHYSICAL_EYE.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of PHYSICAL_EYE, PHYSICAL_SCREEN,
 VIRTUAL_EYE, or VIRTUAL_SCREEN</DL>
</DD>
</DL>
<HR>

<A NAME="getFrontClipPolicy()"><!-- --></A><H3>
getFrontClipPolicy</H3>
<PRE>
public int <B>getFrontClipPolicy</B>()</PRE>
<DL>
<DD>Returns the view model's current front clip policy.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>one of:
 VIRTUAL_EYE, PHYSICAL_EYE, VIRTUAL_SCREEN, or PHYSICAL_SCREEN</DL>
</DD>
</DL>
<HR>

<A NAME="setBackClipPolicy(int)"><!-- --></A><H3>
setBackClipPolicy</H3>
<PRE>
public void <B>setBackClipPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the view model's back clip policy, the policy Java 3D uses
 in computing where to place the back clip plane. The variable 
 can contain one of:
 <UL>
 <LI>VIRTUAL_EYE, to specify that the associated distance is
 from the eye and in units of virtual distance
 </LI>
 <LI>PHYSICAL_EYE, to specify that the associated distance is
 from the eye and in units of physical distance (meters)
 </LI>
 <LI>VIRTUAL_SCREEN, to specify that the associated distance is
 from the screen and in units of virtual distance
 </LI>
 <LI>PHYSICAL_SCREEN, to specify that the associated distance is
 from the screen and in units of physical distance (meters)
 </LI>
 </UL>
 The default back clip policy is PHYSICAL_EYE.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of PHYSICAL_EYE, PHYSICAL_SCREEN,
 VIRTUAL_EYE, or VIRTUAL_SCREEN</DL>
</DD>
</DL>
<HR>

<A NAME="getBackClipPolicy()"><!-- --></A><H3>
getBackClipPolicy</H3>
<PRE>
public int <B>getBackClipPolicy</B>()</PRE>
<DL>
<DD>Returns the view model's current back clip policy.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>one of:
 VIRTUAL_EYE, PHYSICAL_EYE, VIRTUAL_SCREEN, or PHYSICAL_SCREEN</DL>
</DD>
</DL>
<HR>

<A NAME="setVisibilityPolicy(int)"><!-- --></A><H3>
setVisibilityPolicy</H3>
<PRE>
public void <B>setVisibilityPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the visibility policy for this view.  This attribute 
 is one of:
 <UL>
 <LI>VISIBILITY_DRAW_VISIBLE, to specify that only visible objects
 are drawn.
 </LI>
 <LI>VISIBILITY_DRAW_INVISIBLE, to specify that only invisible objects
 are drawn.
 </LI>
 <LI>VISIBILITY_DRAW_ALL, to specify that both visible and
 invisible objects are drawn.
 </LI>
 </UL>
 The default visibility policy is VISIBILITY_DRAW_VISIBLE.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of VISIBILITY_DRAW_VISIBLE,
 VISIBILITY_DRAW_INVISIBLE, or VISIBILITY_DRAW_ALL.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/RenderingAttributes.html#setVisible(boolean)"><CODE>RenderingAttributes.setVisible(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getVisibilityPolicy()"><!-- --></A><H3>
getVisibilityPolicy</H3>
<PRE>
public int <B>getVisibilityPolicy</B>()</PRE>
<DL>
<DD>Retrieves the current visibility policy.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>one of:
 VISIBILITY_DRAW_VISIBLE,
 VISIBILITY_DRAW_INVISIBLE, or VISIBILITY_DRAW_ALL.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTransparencySortingPolicy(int)"><!-- --></A><H3>
setTransparencySortingPolicy</H3>
<PRE>
public void <B>setTransparencySortingPolicy</B>(int&nbsp;policy)</PRE>
<DL>
<DD>Sets the transparency sorting policy for this view.  This attribute 
 is one of:

 <UL>
 <LI>TRANSPARENCY_SORT_NONE, to specify that no depth sorting of
 transparent objects is performed.  Transparent objects are
 drawn after opaque objects, but are not sorted from back to
 front.</LI>

 <LI>TRANSPARENCY_SORT_GEOMETRY, to specify that transparent
 objects are depth-sorted on a per-geometry basis.  Each
 geometry object of each transparent Shape3D node is drawn from
 back to front.  Note that this policy will not split geometry
 into smaller pieces, so intersecting or intertwined objects may
 not be sorted correctly.</LI>
 </UL>

 The default policy is TRANSPARENCY_SORT_NONE.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>policy</CODE> - the new policy, one of TRANSPARENCY_SORT_NONE
 or TRANSPARENCY_SORT_GEOMETRY.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTransparencySortingPolicy()"><!-- --></A><H3>
getTransparencySortingPolicy</H3>
<PRE>
public int <B>getTransparencySortingPolicy</B>()</PRE>
<DL>
<DD>Retrieves the current transparency sorting policy.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>one of:
 TRANSPARENCY_SORT_NONE or TRANSPARENCY_SORT_GEOMETRY.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTrackingEnable(boolean)"><!-- --></A><H3>
setTrackingEnable</H3>
<PRE>
public void <B>setTrackingEnable</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Turns head tracking on or off for this view.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - specifies whether head tracking is enabled or
 disabled for this view</DL>
</DD>
</DL>
<HR>

<A NAME="getTrackingEnable()"><!-- --></A><H3>
getTrackingEnable</H3>
<PRE>
public boolean <B>getTrackingEnable</B>()</PRE>
<DL>
<DD>Returns a status flag indicating whether or not head tracking
 is enabled.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag telling whether head tracking is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="setUserHeadToVworldEnable(boolean)"><!-- --></A><H3>
setUserHeadToVworldEnable</H3>
<PRE>
public void <B>setUserHeadToVworldEnable</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Turns on or off the continuous
 updating of the userHeadToVworld transform.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - enables or disables continuous updating</DL>
</DD>
</DL>
<HR>

<A NAME="getUserHeadToVworldEnable()"><!-- --></A><H3>
getUserHeadToVworldEnable</H3>
<PRE>
public boolean <B>getUserHeadToVworldEnable</B>()</PRE>
<DL>
<DD>Returns a status flag indicating whether or not
 Java 3D is continuously updating the userHeadToVworldEnable transform.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag indicating if continuously updating userHeadToVworld</DL>
</DD>
</DL>
<HR>

<A NAME="getSensorToVworld(javax.media.j3d.Sensor, javax.media.j3d.Transform3D)"><!-- --></A><H3>
getSensorToVworld</H3>
<PRE>
public void <B>getSensorToVworld</B>(<A HREF="../../../javax/media/j3d/Sensor.html" title="class in javax.media.j3d">Sensor</A>&nbsp;sensor,
                              <A HREF="../../../javax/media/j3d/Transform3D.html" title="class in javax.media.j3d">Transform3D</A>&nbsp;t)</PRE>
<DL>
<DD>Computes the sensor to virtual-world transform
 and copies that value into the transform provided.
 The computed transforms takes points in the sensor's coordinate
 system and produces the point's corresponding value in
 virtual-world coordinates.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sensor</CODE> - the sensor in question<DD><CODE>t</CODE> - the object that will receive the transform</DL>
</DD>
</DL>
<HR>

<A NAME="getSensorHotspotInVworld(javax.media.j3d.Sensor, javax.vecmath.Point3f)"><!-- --></A><H3>
getSensorHotspotInVworld</H3>
<PRE>
public void <B>getSensorHotspotInVworld</B>(<A HREF="../../../javax/media/j3d/Sensor.html" title="class in javax.media.j3d">Sensor</A>&nbsp;sensor,
                                     <A HREF="../../../javax/vecmath/Point3f.html" title="class in javax.vecmath">Point3f</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the position of the specified Sensor's 
 hotspot in virtual-world coordinates
 and copies that value into the position provided.
 This value is derived from other values and is read-only.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sensor</CODE> - the sensor in question<DD><CODE>position</CODE> - the variable that will receive the position</DL>
</DD>
</DL>
<HR>

<A NAME="getSensorHotspotInVworld(javax.media.j3d.Sensor, javax.vecmath.Point3d)"><!-- --></A><H3>
getSensorHotspotInVworld</H3>
<PRE>
public void <B>getSensorHotspotInVworld</B>(<A HREF="../../../javax/media/j3d/Sensor.html" title="class in javax.media.j3d">Sensor</A>&nbsp;sensor,
                                     <A HREF="../../../javax/vecmath/Point3d.html" title="class in javax.vecmath">Point3d</A>&nbsp;position)</PRE>
<DL>
<DD>Retrieves the position of the specified Sensor's 
 hotspot in virtual-world coordinates
 and copies that value into the position provided.
 This value is derived from other values and is read-only.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sensor</CODE> - the sensor in question<DD><CODE>position</CODE> - the variable that will receive the position</DL>
</DD>
</DL>
<HR>

<A NAME="setCanvas3D(javax.media.j3d.Canvas3D, int)"><!-- --></A><H3>
setCanvas3D</H3>
<PRE>
public void <B>setCanvas3D</B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D,
                        int&nbsp;index)</PRE>
<DL>
<DD>Sets given Canvas3D at the given index position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>canvas3D</CODE> - the given Canvas3D to be set<DD><CODE>index</CODE> - the position to be set
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the specified canvas is
 a stereo canvas with a monoscopicEyePolicy of CYCLOPEAN_EYE_VIEW,
 and the viewPolicy for this view is HMD_VIEW
<DD><CODE><A HREF="../../../javax/media/j3d/IllegalSharingException.html" title="class in javax.media.j3d">IllegalSharingException</A></CODE> - if the specified canvas is
 associated with another view</DL>
</DD>
</DL>
<HR>

<A NAME="getCanvas3D(int)"><!-- --></A><H3>
getCanvas3D</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A> <B>getCanvas3D</B>(int&nbsp;index)</PRE>
<DL>
<DD>Gets the Canvas3D at the specified index position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the position from which to get Canvas3D object
<DT><B>Returns:</B><DD>the Canvas3D at the sprcified index position</DL>
</DD>
</DL>
<HR>

<A NAME="getAllCanvas3Ds()"><!-- --></A><H3>
getAllCanvas3Ds</H3>
<PRE>
public java.util.Enumeration <B>getAllCanvas3Ds</B>()</PRE>
<DL>
<DD>Gets the enumeration object of all the Canvas3Ds.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the enumeration object of all the Canvas3Ds.</DL>
</DD>
</DL>
<HR>

<A NAME="numCanvas3Ds()"><!-- --></A><H3>
numCanvas3Ds</H3>
<PRE>
public int <B>numCanvas3Ds</B>()</PRE>
<DL>
<DD>Returns the number of Canvas3Ds in this View.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the number of Canvas3Ds in this View<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="addCanvas3D(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
addCanvas3D</H3>
<PRE>
public void <B>addCanvas3D</B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D)</PRE>
<DL>
<DD>Adds the given Canvas3D at the end of the list.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>canvas3D</CODE> - the Canvas3D to be added
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the specified canvas is
 a stereo canvas with a monoscopicEyePolicy of CYCLOPEAN_EYE_VIEW,
 and the viewPolicy for this view is HMD_VIEW
<DD><CODE><A HREF="../../../javax/media/j3d/IllegalSharingException.html" title="class in javax.media.j3d">IllegalSharingException</A></CODE> - if the specified canvas is
 associated with another view</DL>
</DD>
</DL>
<HR>

<A NAME="insertCanvas3D(javax.media.j3d.Canvas3D, int)"><!-- --></A><H3>
insertCanvas3D</H3>
<PRE>
public void <B>insertCanvas3D</B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D,
                           int&nbsp;index)</PRE>
<DL>
<DD>Inserts the Canvas3D at the given index position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>canvas3D</CODE> - the Canvas3D to be inserted<DD><CODE>index</CODE> - the position to be inserted at
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the specified canvas is
 a stereo canvas with a monoscopicEyePolicy of CYCLOPEAN_EYE_VIEW,
 and the viewPolicy for this view is HMD_VIEW
<DD><CODE><A HREF="../../../javax/media/j3d/IllegalSharingException.html" title="class in javax.media.j3d">IllegalSharingException</A></CODE> - if the specified canvas is
 associated with another view</DL>
</DD>
</DL>
<HR>

<A NAME="removeCanvas3D(int)"><!-- --></A><H3>
removeCanvas3D</H3>
<PRE>
public void <B>removeCanvas3D</B>(int&nbsp;index)</PRE>
<DL>
<DD>Removes the Canvas3D from the given index position.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - the position of Canvas3D object to be removed</DL>
</DD>
</DL>
<HR>

<A NAME="indexOfCanvas3D(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
indexOfCanvas3D</H3>
<PRE>
public int <B>indexOfCanvas3D</B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D)</PRE>
<DL>
<DD>Retrieves the index of the specified Canvas3D in
 this View's list of Canvas3Ds
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>canvas3D</CODE> - the Canvas3D to be looked up.
<DT><B>Returns:</B><DD>the index of the specified Canvas3D;
 returns -1 if the object is not in the list.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeCanvas3D(javax.media.j3d.Canvas3D)"><!-- --></A><H3>
removeCanvas3D</H3>
<PRE>
public void <B>removeCanvas3D</B>(<A HREF="../../../javax/media/j3d/Canvas3D.html" title="class in javax.media.j3d">Canvas3D</A>&nbsp;canvas3D)</PRE>
<DL>
<DD>Removes the specified Canvas3D from this View's
 list of Canvas3Ds.
 If the specified object is not in the list, the list is not modified.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>canvas3D</CODE> - the Canvas3D to be removed.</DL>
</DD>
</DL>
<HR>

<A NAME="removeAllCanvas3Ds()"><!-- --></A><H3>
removeAllCanvas3Ds</H3>
<PRE>
public void <B>removeAllCanvas3Ds</B>()</PRE>
<DL>
<DD>Removes all Canvas3Ds from this View.
<P>
<DD><DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCurrentFrameStartTime()"><!-- --></A><H3>
getCurrentFrameStartTime</H3>
<PRE>
public long <B>getCurrentFrameStartTime</B>()</PRE>
<DL>
<DD>This method returns the time at which the most recent rendering
 frame started.  It is defined as the number of milliseconds
 since January 1, 1970 00:00:00 GMT.
 Since multiple canvases might be attached to this View,
 the start of a frame is defined as the point in time just prior
 to clearing any canvas attached to this view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the time at which the most recent rendering frame started</DL>
</DD>
</DL>
<HR>

<A NAME="getLastFrameDuration()"><!-- --></A><H3>
getLastFrameDuration</H3>
<PRE>
public long <B>getLastFrameDuration</B>()</PRE>
<DL>
<DD>This method returns the duration, in milliseconds, of the most
 recently completed rendering frame.  The time taken to render
 all canvases attached to this view is measured.  This duration
 is computed as the difference between the start of the most recently
 completed frame and the end of that frame.
 Since multiple canvases might be attached to this View,
 the start of a frame is defined as the point in time just prior
 to clearing any canvas attached to this view--before preRender
 is called for any canvas.  Similarly, the end of a frame is
 defined as the point in time just after swapping the buffer for
 all canvases--after postSwap is called for all canvases.
 Note that since the frame duration is measured from start to stop
 for this view only, the value returned is not the same as
 frame rate; it measures only the rendering time for this view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the duration, in milliseconds, of the most recently
 completed rendering frame</DL>
</DD>
</DL>
<HR>

<A NAME="getFrameNumber()"><!-- --></A><H3>
getFrameNumber</H3>
<PRE>
public long <B>getFrameNumber</B>()</PRE>
<DL>
<DD>This method returns the frame number for this view.  The frame
 number starts at 0 and is incremented at the start of each
 frame--prior to clearing all the canvases attached to this
 view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current frame number for this view</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxFrameStartTimes()"><!-- --></A><H3>
getMaxFrameStartTimes</H3>
<PRE>
public static int <B>getMaxFrameStartTimes</B>()</PRE>
<DL>
<DD>Retrieves the implementation-dependent maximum number of
 frames whose start times will be recorded by the system.  This
 value is guaranteed to be at least 10 for all implementations
 of the Java 3D API.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the maximum number of frame start times recorded</DL>
</DD>
</DL>
<HR>

<A NAME="getFrameStartTimes(long[])"><!-- --></A><H3>
getFrameStartTimes</H3>
<PRE>
public long <B>getFrameStartTimes</B>(long[]&nbsp;times)</PRE>
<DL>
<DD>Copies the last <i>k</i> frame start time values into
 the user-specified array.  The most recent frame start time is
 copied to location 0 of the array, the next most recent frame
 start time is copied into location 1 of the array, and so forth.
 If times.length is smaller than
 maxFrameStartTimes, then only the last times.length values are
 copied.  If times.length is greater than maxFrameStartTimes,
 then all array elements after index maxFrameStartTimes-1 are
 set to 0.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the frame number of the most recent frame in the array<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#setMinimumFrameCycleTime(long)"><CODE>setMinimumFrameCycleTime(long)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setMinimumFrameCycleTime(long)"><!-- --></A><H3>
setMinimumFrameCycleTime</H3>
<PRE>
public void <B>setMinimumFrameCycleTime</B>(long&nbsp;minimumTime)</PRE>
<DL>
<DD>Sets the minimum frame cycle time, in milliseconds, for this
 view.  The Java 3D renderer will ensure that the time between
 the start of each successive frame is at least the specified
 number of milliseconds.  The default value is 0.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>minimumTime</CODE> - the minimum number of milliseconds between
 successive frames
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>minimumTime < 0</code><DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#getFrameStartTimes(long[])"><CODE>getFrameStartTimes(long[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getMinimumFrameCycleTime()"><!-- --></A><H3>
getMinimumFrameCycleTime</H3>
<PRE>
public long <B>getMinimumFrameCycleTime</B>()</PRE>
<DL>
<DD>Retrieves the minimum frame cycle time, in milliseconds, for this view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the minimum frame cycle time for this view.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/View.html#getFrameStartTimes(long[])"><CODE>getFrameStartTimes(long[])</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setDepthBufferFreezeTransparent(boolean)"><!-- --></A><H3>
setDepthBufferFreezeTransparent</H3>
<PRE>
public void <B>setDepthBufferFreezeTransparent</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Enables or disables automatic freezing of the depth buffer for
 objects rendered
 during the transparent rendering pass (i.e., objects rendered
 using alpha blending) for this view.
 If enabled, depth buffer writes will be disabled during the
 transparent rendering pass regardless of the value of
 the depth buffer write enable flag in the RenderingAttributes
 object for a particular node.
 This flag is enabled by default.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - indicates whether automatic freezing of the depth buffer
 for transparent/antialiased objects is enabled.<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/RenderingAttributes.html#setDepthBufferWriteEnable(boolean)"><CODE>RenderingAttributes.setDepthBufferWriteEnable(boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getDepthBufferFreezeTransparent()"><!-- --></A><H3>
getDepthBufferFreezeTransparent</H3>
<PRE>
public boolean <B>getDepthBufferFreezeTransparent</B>()</PRE>
<DL>
<DD>Retrieves the current value of the depth buffer freeze transparent
 flag for this view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag that indicates whether or not the depth
 buffer is automatically frozen during the transparent rendering pass.</DL>
</DD>
</DL>
<HR>

<A NAME="setSceneAntialiasingEnable(boolean)"><!-- --></A><H3>
setSceneAntialiasingEnable</H3>
<PRE>
public void <B>setSceneAntialiasingEnable</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Enables or disables scene antialiasing for this view.
 If enabled, the entire scene will be antialiased on
 each canvas in which scene antialiasing is available.
 Scene antialiasing is disabled by default.
 <p>
 NOTE: Scene antialiasing is ignored in pure immediate mode,
 but is supported in mixed-immediate mode.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - indicates whether scene antialiasing is enabled<DT><B>See Also:</B><DD><A HREF="../../../javax/media/j3d/Canvas3D.html#queryProperties()"><CODE>Canvas3D.queryProperties()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getSceneAntialiasingEnable()"><!-- --></A><H3>
getSceneAntialiasingEnable</H3>
<PRE>
public boolean <B>getSceneAntialiasingEnable</B>()</PRE>
<DL>
<DD>Returns a flag that indicates whether or not scene antialiasing
 is enabled for this view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag that indicates whether scene antialiasing is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="setLocalEyeLightingEnable(boolean)"><!-- --></A><H3>
setLocalEyeLightingEnable</H3>
<PRE>
public void <B>setLocalEyeLightingEnable</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Sets a flag that indicates whether the local eyepoint is used in
 lighting calculations for perspective projections.
 If this flag is set to true, the view vector is calculated per-vertex
 based on the direction from the actual eyepoint to the vertex.
 If this flag is set to false, a single view vector is computed from
 the eyepoint to the center of the view frustum.  This is
 called infinite eye lighting.
 Local eye lighting is disabled by default, and is ignored for
 parallel projections.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - indicates whether local eye lighting is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="getLocalEyeLightingEnable()"><!-- --></A><H3>
getLocalEyeLightingEnable</H3>
<PRE>
public boolean <B>getLocalEyeLightingEnable</B>()</PRE>
<DL>
<DD>Retrieves a flag that indicates whether or not local eye lighting
 is enabled for this view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a flag that indicates whether local eye lighting is enabled</DL>
</DD>
</DL>
<HR>

<A NAME="attachViewPlatform(javax.media.j3d.ViewPlatform)"><!-- --></A><H3>
attachViewPlatform</H3>
<PRE>
public void <B>attachViewPlatform</B>(<A HREF="../../../javax/media/j3d/ViewPlatform.html" title="class in javax.media.j3d">ViewPlatform</A>&nbsp;vp)</PRE>
<DL>
<DD>Attach viewPlatform structure to this view.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vp</CODE> - the viewPlatform to be attached</DL>
</DD>
</DL>
<HR>

<A NAME="getViewPlatform()"><!-- --></A><H3>
getViewPlatform</H3>
<PRE>
public <A HREF="../../../javax/media/j3d/ViewPlatform.html" title="class in javax.media.j3d">ViewPlatform</A> <B>getViewPlatform</B>()</PRE>
<DL>
<DD>Retrieves the currently attached ViewPlatform object
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the currently attached ViewPlatform</DL>
</DD>
</DL>
<HR>

<A NAME="stopBehaviorScheduler()"><!-- --></A><H3>
stopBehaviorScheduler</H3>
<PRE>
public final long[] <B>stopBehaviorScheduler</B>()</PRE>
<DL>
<DD>Stops the behavior scheduler after all
 currently scheduled behaviors are executed.  Any frame-based
 behaviors scheduled to wake up on the next frame will be
 executed at least once before the behavior scheduler is
 stopped.
 <p>
 NOTE: This is a heavy-weight method
 intended for verification and image capture (recording); it
 is <i>not</i> intended to be used for flow control.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a pair of integers that specify the beginning and ending
 time (in milliseconds since January 1, 1970 00:00:00 GMT)
 of the behavior scheduler's last pass
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this method is called
 from a Behavior method or from any Canvas3D render callback
 method</DL>
</DD>
</DL>
<HR>

<A NAME="startBehaviorScheduler()"><!-- --></A><H3>
startBehaviorScheduler</H3>
<PRE>
public final void <B>startBehaviorScheduler</B>()</PRE>
<DL>
<DD>Starts the behavior scheduler running after it has been stopped.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this method is called
 from a Behavior method or from any Canvas3D render callback
 method</DL>
</DD>
</DL>
<HR>

<A NAME="isBehaviorSchedulerRunning()"><!-- --></A><H3>
isBehaviorSchedulerRunning</H3>
<PRE>
public final boolean <B>isBehaviorSchedulerRunning</B>()</PRE>
<DL>
<DD>Retrieves a flag that indicates whether the behavior scheduler is
 currently running.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if the behavior scheduler is running, false otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this method is called
 from a Behavior method or from any Canvas3D render callback
 method</DL>
</DD>
</DL>
<HR>

<A NAME="stopView()"><!-- --></A><H3>
stopView</H3>
<PRE>
public final void <B>stopView</B>()</PRE>
<DL>
<DD>Stops traversing the scene graph for this
 view after the current state of the scene graph is reflected on
 all canvases attached to this view.  The renderers associated
 with these canvases are also stopped.
 <p>
 NOTE: This is a heavy-weight method
 intended for verification and image capture (recording); it
 is <i>not</i> intended to be used for flow control.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this method is called
 from a Behavior method or from any Canvas3D render callback
 method</DL>
</DD>
</DL>
<HR>

<A NAME="startView()"><!-- --></A><H3>
startView</H3>
<PRE>
public final void <B>startView</B>()</PRE>
<DL>
<DD>Starts
 traversing this view, and starts the renderers associated
 with all canvases attached to this view.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this method is called
 from a Behavior method or from any Canvas3D render callback
 method</DL>
</DD>
</DL>
<HR>

<A NAME="isViewRunning()"><!-- --></A><H3>
isViewRunning</H3>
<PRE>
public final boolean <B>isViewRunning</B>()</PRE>
<DL>
<DD>Retrieves a flag that indicates whether the traverser is
 currently running on this view.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if the traverser is running, false otherwise
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this method is called
 from a Behavior method or from any Canvas3D render callback
 method</DL>
</DD>
</DL>
<HR>

<A NAME="renderOnce()"><!-- --></A><H3>
renderOnce</H3>
<PRE>
public void <B>renderOnce</B>()</PRE>
<DL>
<DD>Renders one frame for a stopped View.  Functionally, this
 method is equivalent to <code>startView()</code> followed by
 <code>stopview()</code>, except that it is atomic, which
 guarantees that only one frame is rendered.
<P>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if this method is called from
 a Behavior method or from any Canvas3D render callback, or if
 the view is currently running.<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="repaint()"><!-- --></A><H3>
repaint</H3>
<PRE>
public void <B>repaint</B>()</PRE>
<DL>
<DD>Requests that this View be scheduled for rendering as soon as
 possible.  The repaint method may return before the frame has
 been rendered.  If the view is stopped, or if the view is
 continuously running (for example, due to a free-running
 interpolator), this method will have no effect.  Most
 applications will not need to call this method, since any
 update to the scene graph or to viewing parameters will
 automatically cause all affected views to be rendered.
<P>
<DD><DL>
<DT><B>Since:</B></DT>
  <DD>Java 3D 1.2</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/media/j3d/TriangleStripArray.html" title="class in javax.media.j3d"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/media/j3d/ViewPlatform.html" title="class in javax.media.j3d"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/media/j3d/View.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="View.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size="-1">Copyright (c) 2006 Sun Microsystems, Inc. All rights reserved. Use is subject to <a href="../../../LICENSE-SPEC.html">license terms</a>.
</BODY>
</HTML>
